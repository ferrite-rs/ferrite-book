<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing Session-Typed Ferrite Programs in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ferrite.html"><strong aria-hidden="true">1.</strong> Writing Session-Typed Ferrite Programs in Rust</a></li><li class="chapter-item expanded "><a href="01-getting-started/00-getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-getting-started/01-installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="01-getting-started/02-hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="01-getting-started/03-communication.html"><strong aria-hidden="true">2.3.</strong> Client Communication</a></li><li class="chapter-item expanded "><a href="01-getting-started/04-type-errors.html"><strong aria-hidden="true">2.4.</strong> Type Errors</a></li><li class="chapter-item expanded "><a href="01-getting-started/05-session-types.html"><strong aria-hidden="true">2.5.</strong> Session Types</a></li><li class="chapter-item expanded "><a href="01-getting-started/06-macros.html"><strong aria-hidden="true">2.6.</strong> Macros</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Main Concepts</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">3.1.</strong> Protocols</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.2.</strong> Linear Context</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Partial Sessions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Channel Selectors</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Basic Constructs</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Termination</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Send / Receive Values</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Receive Channels</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> External Choice</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> Internal Choice</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Advanced Constructs</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Shared Session Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> Include Session</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Recursive Session Types</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Example Usage</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Communication Protocols</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Shared Resources</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Ferrite Internals</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Higher Kinded Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Cloaking Constraints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Optics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Row Polymorphism</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Conclusion</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> TODO</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Session-Typed Ferrite Programs in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#writing-session-typed-ferrite-programs-in-rust-draft" id="writing-session-typed-ferrite-programs-in-rust-draft">Writing Session-Typed Ferrite Programs in Rust (Draft)</a></h1>
<p>Welcome to Writing Session-Typed Ferrite Programs in Rust!
This is an introductory guide on how to use
<a href="https://github.com/maybevoid/ferrite">Ferrite</a>,
an EDSL (embedded domain specific language),
for writing session-typed programs in Rust.</p>
<p>In this book you will learn about writing Ferrite programs
with <em>linear</em> session types, which channel variables must be used
<em>exactly once</em>. This is in contrast with normal Rust programs with
<em>affine</em> types, which variables can be used <em>at most once</em>.</p>
<p>You will learn how session types can be used to define
<em>communication protocols</em> between different parts of a Rust program.
You will see how Ferrite can help elminate the boilerplates of managing
communication using plain Rust channels, and enforce protocol
compliance through linearity.</p>
<p>Finally you will also learn about <em>shared session types</em>, which
you can use to define services that can be safely shared among
multiple linear clients. You will learn how shared session types
can be used to implement common communication patterns
such as client-server communication.</p>
<h2><a class="header" href="#work-in-progress" id="work-in-progress">Work In Progress</a></h2>
<p>Ferrite is currently still in development, with parts of the code subject
to change. This book is also a work in progress, with most of the content
yet to be written. Keep an eye on the
<a href="https://github.com/maybevoid/ferrite">ferrite</a>
and <a href="https://github.com/maybevoid/ferrite-book">ferrite-book</a> repositories
for any update.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>In this section, we will get a quick taste of Ferrite with a high level
overview of the language.
You will learn about how to start using Ferrite to build
a toy example program in Ferrite.</p>
<p>This book assumes that you already know the basic concepts in Rust,
as well as advanced concepts such as
<a href="https://doc.rust-lang.org/book/ch10-00-generics.html">generic types</a>,
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>,
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">associated types</a>,
and
<a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">asynchronous programming</a>.
If you haven't learned these concepts, we highly recommend you to first
read the relevant sections in the <a href="https://doc.rust-lang.org/book">Rust book</a>,
and the <a href="https://rust-lang.github.io/async-book">Async book</a>.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>Ferrite is an open source project with the source code available at
<a href="https://github.com/maybevoid/ferrite">GitHub</a>. Ferrite is also published at
<a href="https://crates.io/crates/ferrite-session">crates.io</a> as the Cargo
crate <code>ferrite-session</code>.</p>
<p>To start using Ferrite, simply
<a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">create a new Cargo project</a>
and add <code>ferrite-session</code> as a dependency in <code>Cargo.toml</code>.
To help with defining asynchronous Rust programs, we also recommend
adding <a href="https://docs.rs/async-std/">async-std</a> as a dependency in your Rust project.</p>
<pre><code>[dependencies]
...
ferrite-session = &quot;0.1.0&quot;
async-std = { version = &quot;1.7.0&quot;, features = [&quot;attributes&quot;] }
...
</code></pre>
<p>To use the constructs provided by Ferrite, import everything from the
<code>ferrite_session</code> module:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use ferrite_session::*;
<span class="boring">}
</span></code></pre></pre>
<p>Next, we will learn how to use Ferrite to write a simple hello world program.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<p>In this chapter we will look at two simple programs that implement
hello world in Ferrite.</p>
<h2><a class="header" href="#hello-protocol" id="hello-protocol">Hello Protocol</a></h2>
<p>A session type, a.k.a. a protocol, describes a communication protocol between
two parties: a <em>provider</em> and a <em>client</em>. The provider <em>offers</em> a service
as described by the session type, and the client <em>consumes</em> the provided
service in a linear fashion.</p>
<p>In this example, we will define a simple <code>Hello</code> protocol that has
the session type <code>SendValue &lt; String, End &gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Hello = SendValue &lt; String, End &gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>Hello</code> protocol pretty much self describe the communication protocol:
The provider would send a Rust <code>String</code> value and then terminates. Conversely,
a client for <code>Hello</code> would <em>receive</em> a Rust <code>String</code> value, and then <em>waits</em>
for the provider to terminate.</p>
<p>The type <code>SendValue &lt; T, A &gt;</code> defines a session type that sends a Rust value
<code>T</code>, and then continues with the <em>continuation</em> session type <code>A</code>. The type
<code>End</code> defines a session type that simply terminates. When we combine both
<code>SendValue</code> and <code>End</code> to get <code>SendValue &lt; String, End &gt;</code>, we are effectively
defining a session type that sends a Rust value of type <code>String</code>, and then
<em>continues</em> as session type <code>End</code>, which happens to simply terminates.</p>
<h2><a class="header" href="#hello-world-provider" id="hello-world-provider">Hello World Provider</a></h2>
<p>We first look at how a provider for the <code>Hello</code> protocol can be implemented:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_provider : Session &lt; Hello &gt; =
    send_value! (
      &quot;Hello World!&quot;.to_string(),
      terminate! () );
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, we define a variable named <code>hello_provider</code>
with the Rust type <code>Session &lt; Hello &gt;</code>. The Rust type <code>Session &lt; A &gt;</code> denotes
a Ferrite program that is providing a session type <code>A</code>. In this case,
<code>hello_provider</code> is a Ferrite program that provides the <code>Hello</code> protocol.</p>
<p>In the body of <code>hello_provider</code>, we use the Ferrite macros <code>send_value!</code> and
<code>terminate!</code> to build up our Ferrite program. According to the <code>Hello</code> protocol,
the first step <code>hello_provider</code> needs to do is to send a <code>String</code> value.
To do that, we create a Rust string <code>&quot;Hello World!&quot;.to_string()</code>, and then send
it by calling <code>send_value! ( &quot;Hello World!&quot;.to_string(), ... )</code>.</p>
<p>Other than the <code>&quot;Hello World!&quot;</code> string in the first argument, <code>send_value!</code> also
expects a <em>second</em> argument, which is the <em>continuation</em> after our string value
is sent. In our case, The continuation session type of <code>SendValue &lt; String, End &gt;</code>
is <code>End</code>. As such, there is nothing left to do other than terminating the Ferrite
program, which we can do it by calling <code>terminate!()</code>.</p>
<h2><a class="header" href="#run-session" id="run-session">Run Session</a></h2>
<p>Up to this point, we have only defined a Ferrite program named <code>hello_provider</code>,
but we have not yet execute the program. To run it, we would typically need to
pair it with a client that <em>consumes</em> the offered protocol <code>Hello</code>. However
Ferrite provides a special case for Ferrite programs that offer the session types
<code>SendValue &lt; T, End &gt;</code>. So we can run our <code>hello_provider</code> by calling
<code>run_session_with_result</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let result : String =
    run_session_with_result ( hello_provider ).await;

  println!(&quot;{}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<p>Ferrite provides <code>run_session_with_result</code> as a default way of handling
Ferrite programs offering the session type <code>SendValue &lt; T, End &gt;</code>,
because they are trivial to handle.
This can be done by receiving the Rust value sent from the provider,
waits for the provider to terminate, and then returns to the caller.
The function is an async function, so we have to use the <code>.await</code>
syntax to wait for Ferrite to run the program and return the results.</p>
<p>After getting the result back, we can print the received string using
<code>println!</code>, and we can expect <code>&quot;Hello World!&quot;</code> to be printed at this point.</p>
<h2><a class="header" href="#full-hello-world-program" id="full-hello-world-program">Full Hello World Program</a></h2>
<p>Putting everything together, our first hello world program is written as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use ferrite_session::*;

type Hello = SendValue &lt; String, End &gt;;

#[async_std::main]
async fn main () {
  let hello_provider : Session &lt; Hello &gt; =
    send_value! (
      &quot;Hello World!&quot;.to_string(),
      terminate! () );

  let result : String =
    run_session_with_result ( hello_provider ).await;

  println!(&quot;{}&quot;, result);
}
</code></pre></pre>
<p>Our Rust program defines an async <code>main</code> function using the <code>#[async_std::main]</code>
attribute provided by <code>async-std</code>. Inside the main body, we define our provider
Ferrite program as <code>hello_provider</code>, and then immediately run it using
<code>run_session_with_result</code>. Finally we get back the result string and print it
to the terminal.</p>
<h1><a class="header" href="#client-communication" id="client-communication">Client Communication</a></h1>
<p>In the previous chapter, we defined a hello provider and then run it
immediately using <code>run_session_with_result</code>. However in practical applications,
our Ferrite programs will typically have more complex session types, and
we would want to run multiple programs in parallel that communicate with
each others.</p>
<p>To demonstrate that, instead of running <code>hello_provider</code> directly, we can
define a <code>hello_client</code> that <em>communicates</em> with a provider of the <code>Hello</code>
protocol, and then link it with <code>hello_provider</code>.</p>
<p>First, we define <code>hello_client</code> to have the following type:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client :
  Session &lt;
    ReceiveChannel &lt; Hello, End &gt;
  &gt; = ...
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>hello_client</code> has the Rust type <code>Session &lt; ReceiveChannel &lt; Hello, End &gt; &gt;</code>,
indicating that it is a Ferrite program offering the session type
<code>ReceiveChannel &lt; Hello, End &gt;</code>. Here we encounter a new session type in the form
<code>ReceiveChannel &lt; A, B &gt;</code>, which is used to <em>receive a channel</em> of session type
<code>A</code> offered by some provider, and then continue offering session type <code>B</code>.</p>
<h2><a class="header" href="#channels" id="channels">Channels</a></h2>
<p>Ferrite allows sending and receiving of <em>channels</em>, which represent the client
end point to communicate with a provider that offers the channel's session type.
At high level, we can think of receiving a channel using <code>ReceiveChannel &lt; A, B &gt;</code>
is similar to plain Rust functions with function traits like <code>FnOnce (A) -&gt; B</code>.
In other words, <code>ReceiveChannel</code> is the equivalent of function types in Ferrite.</p>
<p>There is however one important distinction of <code>ReceiveChannel</code> from regular
Rust functions. That is channels received from <code>ReceiveChannel</code> must be
used <em>linearly</em>, i.e. they cannot be ignored or dropped.
We will revisit this property in later chapters to see why linearity is
important, and why bare Rust code is not sufficient to support linearity.</p>
<p>Now back to our <code>hello_client</code> example. The session type
<code>ReceiveChannel &lt; Hello, End &gt;</code> indicates that <code>hello_client</code> is <em>receiving</em>
a channel of session type <code>Hello</code>, and then terminates with <code>End</code>.
To implement such a session type, we can implement <code>hello_client</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client :
    Session &lt;
      ReceiveChannel &lt; Hello, End &gt;
    &gt; =
    receive_channel! ( provider =&gt; {
      receive_value_from! ( provider, greeting =&gt; {
        println! ( &quot;Received greetings from provider: {}&quot;, greeting );
          wait! ( provider, terminate! () )
      })
    });
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>hello_client</code> body looks slightly more complicated than <code>hello_provider</code>.
To understand what's going on, we will go through each line of
<code>hello_client</code>'s body. Starting with <code>receive_channel!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>receive_channel! ( provider =&gt; {
  ...
})
<span class="boring">}
</span></code></pre></pre>
<p>To match the final session type <code>ReceiveChannel &lt; Hello, End &gt;</code> that is
offered by <code>hello_client</code>, we use <code>receive_channel!</code> to receive a
channel of session type <code>Hello</code>, and then binds it to the <em>channel variable</em>
<code>provider</code>. This is similar to a Rust function accepting an argument
and bind it to a variable.</p>
<p>Inside the continuation <code>...</code>, since we have received the <code>Hello</code> channel
already, we will continue to offer the session type <code>End</code>.  To do that,
we just need to eventually terminate <code>hello_client</code>. However we cannot
terminate <code>hello_client</code> just yet, because the channel variable <code>provider</code>
is <em>linear</em>, and we must fully consume it before we can terminate.</p>
<p>Recall that <code>Hello</code> is a type alias, so the actual session type of
the channel variable <code>provider</code> is <code>SendValue &lt; String, End &gt;</code>.
But instead of having to offer that, we are acting as the <em>client</em>
to consume the session type <code>SendValue &lt; String, End &gt;</code>. Since the provider
is expected to send a <code>String</code> value, as a client we are expected to
<em>receive</em> a <code>String</code> value from the provider. We can do that using
<code>receive_value_from!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>receive_value_from! ( provider, greeting =&gt; {
  println! ( &quot;Received greetings from provider: {}&quot;, greeting );
  ...
})
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>receive_value_from!</code> to receive a value sent from the <code>provider</code>
channel, and then bind the received <code>String</code> value to the Rust variable
<code>greeting</code>. We then print out the value of <code>greeting</code> using <code>println!</code>.
Following that, in the continuation <code>...</code>, the session type
of <code>provider</code> <em>changes</em> from <code>SendValue &lt; String, End &gt;</code> to
become <code>End</code>.</p>
<p>Unlike regular Rust variables, each time we interacts with a channel
variable, the session type of the channel variable is <em>updated</em>
to its continuation session type. Since Ferrite channels are linear,
we have to continuously interact with the channel until it is
fully terminated.</p>
<p>After calling <code>receive_value_from!</code>, we have the channel variable
<code>provider</code> with session type <code>End</code>, and we need to offer the session
type <code>End</code> by terminating. But we can't terminate just yet, because
<code>End</code> simply indicates that the provider will eventually terminates,
but may not yet been terminated. Hence we would first have to wait
for <code>provider</code> to terminate using <code>wait!</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait! ( provider, terminate! () )
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>wait!</code> to wait for the provider on the other side of a
channel to terminate. After that, the <code>provider</code> channel is discarded,
and we don't have anymore unused channel variable. With that, we
can finally terminate our program using <code>terminate!()</code>.</p>
<h2><a class="header" href="#linking-provider-with-client" id="linking-provider-with-client">Linking Provider With Client</a></h2>
<p>We have now defined a <code>hello_client</code> program that can accept channel
from any provider offering the session type <code>Hello</code>.
In theory, we can call <code>hello_client</code> with any provider that offers
<code>Hello</code>, not just <code>hello_provider</code>.</p>
<p>To link <code>hello_client</code> specifically with <code>hello_provider</code>, we have to
explicitly ask Ferrite to perform the linking. This can be done
using <code>apply_channel</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let main : Session &lt; End &gt; =
    apply_channel ( hello_client, hello_provider );
<span class="boring">}
</span></code></pre></pre>
<p>The <code>apply_channel</code> construct is provided by Ferrite to link a
client Ferrite program of session type <code>ReceiveChannel &lt; A, B &gt;</code>
with a provider Ferrite program of session type <code>A</code>,
resulting in a new Ferrite program of session type <code>B</code>
as the result.</p>
<p>We can think of the form <code>apply_channel(f, x)</code> as being similar similar to
regular function application in the form <code>f(x)</code>. With <code>f</code> having the Rust type
<code>FnOnce(A) -&gt; B</code> and <code>x</code> having the Rust type <code>A</code>, the result type of applying
<code>x</code> to <code>func</code> would be <code>B</code>.</p>
<h2><a class="header" href="#run-session-1" id="run-session-1">Run Session</a></h2>
<p>After applying <code>hello_provider</code> to <code>hello_client</code>, we now have a single <code>main</code>
program. When <code>main</code> is executed, it will run both <code>hello_provider</code> and
<code>hello_client</code> in parallel, and establish a communication channel between
the two processes.</p>
<p>Since <code>main</code> has the session type <code>End</code>, we can use the Ferrite construct
<code>run_session</code> to run the program:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  run_session ( main ).await;
<span class="boring">}
</span></code></pre></pre>
<p><code>run_session</code> accepts any Ferrite program offering the session type <code>End</code>,
executes the program, and wait for it to terminate. <code>run_session</code> is
similar to <code>run_session_with_result</code>, other than it does not expect
the Ferrite program to send back any Rust value as the result.</p>
<h2><a class="header" href="#full-program" id="full-program">Full Program</a></h2>
<p>Putting everything together, we now have our second hello world program
that is made of a <code>hello_provider</code> and a <code>hello_client</code> communicating
with each others.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use ferrite_session::*;

type Hello = SendValue &lt; String, End &gt;;

#[async_std::main]
async fn main () {
  let hello_provider : Session &lt; Hello &gt; =
    send_value! (
      &quot;Hello World!&quot;.to_string(),
      terminate! () );

  let hello_client :
    Session &lt;
      ReceiveChannel &lt; Hello, End &gt;
    &gt; =
    receive_channel! ( provider =&gt; {
      receive_value_from! ( provider, greeting =&gt; {
        println! ( &quot;Received greetings from provider: {}&quot;, greeting );
          wait! ( provider, terminate! () )
      })
    });

  let main : Session &lt; End &gt; =
    apply_channel ( hello_client, hello_provider );

  run_session ( main ).await;
}
</code></pre></pre>
<h1><a class="header" href="#type-errors" id="type-errors">Type Errors</a></h1>
<p>The way we write a Ferrite program is quite different from how we typically
write a Rust program. This is because Ferrite makes use of Rust's type system
to provide additional safeguard on how session type channels can be used.</p>
<p>We can take a quick look of some error messages raised when our Ferrite
programs are written incorrectly.</p>
<h2><a class="header" href="#an-incorrect-hello-provider" id="an-incorrect-hello-provider">An Incorrect Hello Provider</a></h2>
<p>Let's consider the <code>hello_provider</code> program that we have written in the
previous chapter:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_provider : Session &lt; Hello &gt; =
    send_value! (
      &quot;Hello World!&quot;.to_string(),
      terminate! () );
<span class="boring">}
</span></code></pre></pre>
<p>According to the <code>Hello</code> protocol, <code>SendValue &lt; String, End &gt;</code>,
<code>hello_provider</code> is supposed to send a string value before terminating.
But what if we implement <code>hello_provider</code> such that it terminates
immediately without sending a string?</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_provider_incorrect : Session &lt; Hello &gt; = terminate! ();
<span class="boring">}
</span></code></pre></pre>
<p>In this case, if we try to compile our program, we would get a compile
error from Rust showing a message similar to as follows:</p>
<pre><code>error[E0308]: mismatched types
  |
  |   let hello_provider_incorrect : Session &lt; Hello &gt; =
  |                        ----------------- expected due to this
  |     terminate! ();
  |     ^^^^^^^^^^^^^ expected struct `SendValue`, found struct `End`
  |
   = note: expected struct `PartialSession &lt; (), SendValue &lt; String, End &gt; &gt;`
              found struct `PartialSession &lt; _, End &gt;`
</code></pre>
<p>The error message above has been slightly prettified to make it more readable,
but the content remains the same. First of all, we see that the error is about
type mismatch between a <code>PartialSession</code> type, which we will cover in a
<a href="01-getting-started/../03-main-concepts/03-partial-sessions.html">later chapter</a>.</p>
<p>Inside the second type parameter of <code>PartialSession</code>, notice that
there is a mismatch between the expected session type
<code>SendValue &lt; String, End &gt;</code>, and the actual session type <code>End</code>. From that,
we can deduce that <code>hello_provider_incorrect</code> has violated the <code>Hello</code>
protocol, by instead offering the protocol <code>End</code>.</p>
<h2><a class="header" href="#an-incorrect-hello-client" id="an-incorrect-hello-client">An Incorrect Hello Client</a></h2>
<p>The error message we get from <code>hello_provider_incorrect</code> is relatively simple,
as the type mismatch is on the offered channel. On the other hand, recall that
<code>hello_client</code> deals with <em>two</em> channels: one with the receiver end of <code>Hello</code>,
and one that offers the session type <code>End</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client :
    Session &lt;
      ReceiveChannel &lt; Hello, End &gt;
    &gt; =
    receive_channel! ( provider =&gt; {
      receive_value_from! ( provider, greeting =&gt; {
        println! ( &quot;Received greetings from provider: {}&quot;, greeting );
          wait! ( provider, terminate! () )
      })
    });
<span class="boring">}
</span></code></pre></pre>
<p>Based on the protocol specification, it looks like <code>hello_client</code> should be able
to receive a <code>Hello</code> channel, ignores the channel, and proceed to terminate
immediately. So let's try implementing a new client to do just that:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client_incorrect :
  Session &lt;
    ReceiveChannel &lt; Hello, End &gt;
  &gt; =
  receive_channel! ( provider =&gt; {
    terminate! ()
  });
<span class="boring">}
</span></code></pre></pre>
<p>In <code>hello_client_incorrect</code>, the <code>provider</code> channel is ignored after we have received
it, and we proceed to call <code>terminate!</code> immediately. If we try to build this,
we would instead get the following compile error:</p>
<pre><code>error[E0277]: the trait bound `( SendValue &lt; String, End &gt;, () ): EmptyContext` is not satisfied
  |
  |  terminate! ()
  |  ^^^^^^^^^^^^^ the trait `EmptyContext` is not implemented for `( SendValue &lt; String, End &gt;, () )`
</code></pre>
<p>The error can look a bit scary, but it mainly boils down to two constructs:
a new type <code>( SendValue &lt; String, End &gt;, () )</code> and a new trait <code>EmptyContext</code>.</p>
<p>The type <code>( SendValue &lt; String, End &gt;, () )</code> represents the <em>linear context</em> in
<code>hello_client_incorrect</code>, when the expression <code>terminate!()</code> is called. We will
cover the details of linear context in a
<a href="01-getting-started/../03-main-concepts/02-linear-context.html">later chapter</a>. For now it is sufficient
to know that it is used to track the <code>provider</code> channel we have just received,
and it has the session type <code>SendValue &lt; String, End &gt;</code>.</p>
<p>The <code>EmptyContext</code> trait is essentially telling us that in order to use the
<code>terminate!()</code> construct, the current linear context must be empty.
However because we have not yet used up the <code>provider</code> channel, the
linear context is thus not empty, and so we cannot terminate just yet.</p>
<h2><a class="header" href="#enforcing-linear-usage-at-compile-time" id="enforcing-linear-usage-at-compile-time">Enforcing Linear Usage at Compile Time</a></h2>
<p>The error from <code>hello_client_incorrect</code> shows us how Ferrite enforces linear
usage of session type channels at compile time. This can greatly reduce the
chance of us writing incorrect Ferrite programs that just abort in the
middle of communicating with other processes.</p>
<p>The linear usage of Ferrite channels is different from the <em>affine</em> usage
of Rust objects. Consider an equivalent of <code>hello_client</code> implemented
using <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">Rust channels</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_client_rust ( receiver: Receiver &lt; String &gt; ) {
  // drops receiver immediately
}
<span class="boring">}
</span></code></pre></pre>
<p>In standard Rust programs, we establish communication between concurrent
processes by explicitly passing the sender or receiver end of a Rust channel
as function argument. However since the Rust channel is just an affine
Rust object, it is possible that one party drops the channel half way,
intentionally or not.</p>
<p>In the simple case of our <code>Hello</code> protocol, the dropping of a channel
might not seem critical. But what if the protocol is slightly more complicated?</p>
<p>Let's say we have an <code>Ping</code> protocol with the session type
<code>ReceiveValue &lt; String, SendValue &lt; String, End &gt; &gt;</code>. This would require the
provider to receive a string value before sending back another string value,
and vice versa for the client. If a client drops the channel without
sending a value to the provider, the provider would potentially wait forever
without receiving the string.</p>
<p>Even if the provider can somehow detect that the client has dropped the
channel half way, it would still have to raise a runtime error to signal
the error on protocol violation. We would then have to write a lot of
tests to make sure such errors never happen in practice. Even so the
tests may not be exhaustive enough to cover all corner cases.</p>
<p>By enforcing the linear usage of channels at compile time, Ferrite helps
eliminate a broad range of communication errors that can happen due to
incorrect implementations. As we will see in later chapters, using Ferrite
we can safely implement complex communication protocols in our Rust programs,
without having to worry about our programs not correctly following
these protocols.</p>
<h1><a class="header" href="#session-types" id="session-types">Session Types</a></h1>
<p>This chapter provides some supplementary overview of session types,
the type theory that Ferrite is based on. In the discussion we
will talk about some concepts related to
<a href="https://en.wikipedia.org/wiki/Mathematical_logic">logic</a> and
<a href="https://en.wikipedia.org/wiki/Type_theory">type theory</a>.
For readers who are unfamiliar with these topics, feel free
to skip this chapter and move on to the
<a href="01-getting-started/./06-macros.html">next chapter</a>.</p>
<h2><a class="header" href="#background-on-session-types" id="background-on-session-types">Background on Session Types</a></h2>
<p>So far we have been talking about session types without going into details
what it is. Broadly speaking, session types can refer to a branch of
type systems used to model structured communication-based
programming.</p>
<p>From the theoretical perspective,
session types are related to
<a href="https://plato.stanford.edu/entries/logic-linear/">linear logic</a>
through the
<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">Curry–Howard correspondence</a>.
This is in contrast with function languages based on lambda calculus, such as Rust,
Haskell, and OCaml, which have correspondence with
<a href="https://en.wikipedia.org/wiki/Natural_deduction">natural deduction</a>.
Because of this, programming in session types may look unfamiliar to
typical functional programming.</p>
<p>Throughout this book, we will learn about various concepts of session types
from the perspective of a Rust programmer. While this may not be a comprehensive
overview to session types itself, we aim to cover enough of the basics
so that you can explore deeper into session types through other resources.</p>
<h2><a class="header" href="#intuitionistic-vs-classical-linear-logic" id="intuitionistic-vs-classical-linear-logic">Intuitionistic vs Classical Linear Logic</a></h2>
<p>Since session types cover a family of programming languages, readers with
some familiarity with session types may notice that Ferrite's implementation
is quite different from some other session types implementations in
<a href="https://github.com/Munksgaard/session-types">the</a>
<a href="https://github.com/wenkokke/sesh">wild</a>.</p>
<p>As a comparison, Ferrite's implementation of session types is based on
<em>intuitionistic</em> linear logic. This is in contrast with the <em>classical</em>
linear logic formulation that some other session types implementations
are based on.</p>
<p>From the programmers' perspective, there are some key differences when
using the intuitionistic formulation of session types in Ferrite.
For example, you may notice that there is a lack of <em>dualization</em> in
Ferrite. This means that the session type signature remain the
same from the perspective of both the provider and the client.</p>
<p>As we have seen in the <a href="01-getting-started/./03-communication.html">previous chapter</a>,
while a provider sends a string value through a channel with
the session type <code>SendValue &lt; String, End &gt;</code>, the client <em>receives</em>
a value from a channel of the same session type. In comparison,
in a classical formulation, the session type of the same
channel for the client would instead have the session type
<code>ReceiveValue &lt; String, End &gt;</code>.</p>
<p>We leave it to informed readers to decide whether the intuitionistic formulation
of Ferrite provides better intuition of programming in session types.
For the purpose of this book, it is only important for us to clarify
the distinctions, so that readers are better informed when comparing
Ferrite with other session type implementations.</p>
<h2><a class="header" href="#learn-more" id="learn-more">Learn More</a></h2>
<p>If you are interested to learn more about session types, there are
a wealth of type theoretic resources available. To get started,
we recommend watching the OPLSS lecture
<a href="https://www.youtube.com/watch?v=xYhGY0Lq8cw&amp;list=PL0DsGHMPLUWWyBBTpnTBKsYxdkbIoy1q8">Session-Typed Concurrent Programming</a>
given by Stephanie Balzer, our co-author for Ferrite.
The research group <a href="http://groups.inf.ed.ac.uk/abcd/index.html">ABCD</a>
also publishes a comprehensive list of resources related to
session types, including a list of
<a href="http://groups.inf.ed.ac.uk/abcd/session-implementations.html">session types implementations</a>.</p>
<h1><a class="header" href="#macros" id="macros">Macros</a></h1>
<p>(TODO)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
