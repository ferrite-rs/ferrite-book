<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing Session-Typed Ferrite Programs in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="ferrite.html"><strong aria-hidden="true">1.</strong> Writing Session-Typed Ferrite Programs in Rust</a></li><li class="chapter-item expanded "><a href="01-getting-started/00-getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-getting-started/01-installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="01-getting-started/02-hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="01-getting-started/03-communication.html"><strong aria-hidden="true">2.3.</strong> Client Communication</a></li><li class="chapter-item expanded "><a href="01-getting-started/04-type-errors.html"><strong aria-hidden="true">2.4.</strong> Type Errors</a></li><li class="chapter-item expanded "><a href="01-getting-started/05-session-types.html"><strong aria-hidden="true">2.5.</strong> Session Types</a></li></ol></li><li class="chapter-item expanded "><a href="02-main-concepts/00-main-concepts.html"><strong aria-hidden="true">3.</strong> Main Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02-main-concepts/01-protocols.html"><strong aria-hidden="true">3.1.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="02-main-concepts/02-linear-context.html"><strong aria-hidden="true">3.2.</strong> Linear Context</a></li><li class="chapter-item expanded "><a href="02-main-concepts/03-sessions.html"><strong aria-hidden="true">3.3.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="02-main-concepts/04-channel-selectors.html"><strong aria-hidden="true">3.4.</strong> Channel Selectors</a></li><li class="chapter-item expanded "><a href="02-main-concepts/05-hole-driven-development.html"><strong aria-hidden="true">3.5.</strong> Hole Driven Development</a></li></ol></li><li class="chapter-item expanded "><a href="03-basic-constructs/00-basic-constructs.html"><strong aria-hidden="true">4.</strong> Basic Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03-basic-constructs/01-termination.html"><strong aria-hidden="true">4.1.</strong> Termination</a></li><li class="chapter-item expanded "><a href="03-basic-constructs/02-send-receive-values.html"><strong aria-hidden="true">4.2.</strong> Send / Receive Values</a></li><li class="chapter-item expanded "><a href="03-basic-constructs/03-send-receive-channels.html"><strong aria-hidden="true">4.3.</strong> Send / Receive Channels</a></li><li class="chapter-item expanded "><a href="03-basic-constructs/04-external-choice.html"><strong aria-hidden="true">4.4.</strong> External Choice</a></li><li class="chapter-item expanded "><a href="03-basic-constructs/05-internal-choice.html"><strong aria-hidden="true">4.5.</strong> Internal Choice</a></li></ol></li><li class="chapter-item expanded "><a href="04-advanced-constructs/00-advanced-constructs.html"><strong aria-hidden="true">5.</strong> Advanced Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04-advanced-constructs/01-recursive-session-types.html"><strong aria-hidden="true">5.1.</strong> Recursive Session Types</a></li><li class="chapter-item expanded "><a href="04-advanced-constructs/02-communication.html"><strong aria-hidden="true">5.2.</strong> Communication</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Shared Session Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Example Usage</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Communication Protocols</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Shared Resources</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Ferrite Internals</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Higher Kinded Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Cloaking Constraints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Optics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Row Polymorphism</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Conclusion</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> TODO</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Session-Typed Ferrite Programs in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#writing-session-typed-ferrite-programs-in-rust-draft" id="writing-session-typed-ferrite-programs-in-rust-draft">Writing Session-Typed Ferrite Programs in Rust (Draft)</a></h1>
<p>Welcome to Writing Session-Typed Ferrite Programs in Rust!
This is an introductory guide on how to use
<a href="https://github.com/maybevoid/ferrite">Ferrite</a>,
an EDSL (embedded domain specific language),
for writing session-typed programs in Rust.</p>
<p>In this book you will learn about writing Ferrite programs
with <em>linear</em> session types, which channel variables must be used
<em>exactly once</em>. This is in contrast with normal Rust programs with
<em>affine</em> types, which variables can be used <em>at most once</em>.</p>
<p>You will learn how session types can be used to define
<em>communication protocols</em> between different parts of a Rust program.
You will see how Ferrite can help elminate the boilerplates of managing
communication using plain Rust channels, and enforce protocol
compliance through linearity.</p>
<p>Finally you will also learn about <em>shared session types</em>, which
you can use to define services that can be safely shared among
multiple linear clients. You will learn how shared session types
can be used to implement common communication patterns
such as client-server communication.</p>
<h2><a class="header" href="#work-in-progress" id="work-in-progress">Work In Progress</a></h2>
<p>Ferrite is currently still in development, with parts of the code subject
to change. This book is also a work in progress, with most of the content
yet to be written. Keep an eye on the
<a href="https://github.com/maybevoid/ferrite">ferrite</a>
and <a href="https://github.com/maybevoid/ferrite-book">ferrite-book</a> repositories
for any update.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>In this section, we will get a quick taste of Ferrite with a high level
overview of the language.
You will learn about how to start using Ferrite to build
a toy example program in Ferrite.</p>
<p>This book assumes that you already know the basic concepts in Rust,
as well as advanced concepts such as
<a href="https://doc.rust-lang.org/book/ch10-00-generics.html">generic types</a>,
<a href="https://doc.rust-lang.org/book/ch10-02-traits.html">traits</a>,
<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">associated types</a>,
and
<a href="https://rust-lang.github.io/async-book/03_async_await/01_chapter.html">asynchronous programming</a>.
If you haven't learned these concepts, we highly recommend you to first
read the relevant sections in the <a href="https://doc.rust-lang.org/book">Rust book</a>,
and the <a href="https://rust-lang.github.io/async-book">Async book</a>.</p>
<h1><a class="header" href="#installation" id="installation">Installation</a></h1>
<p>Ferrite is an open source project with the source code available at
<a href="https://github.com/maybevoid/ferrite">GitHub</a>. Ferrite is also published at
<a href="https://crates.io/crates/ferrite-session">crates.io</a> as the Cargo
crate <code>ferrite-session</code>.</p>
<p>To start using Ferrite, simply
<a href="https://doc.rust-lang.org/book/ch01-03-hello-cargo.html">create a new Cargo project</a>
and add <code>ferrite-session</code> as a dependency in <code>Cargo.toml</code>.
Ferrite uses <a href="https://docs.rs/async-std/">tokio</a> to spawn async tasks, so you should
add that as a dependency as well.</p>
<pre><code>[dependencies]
tokio = &quot;1.6.1&quot;
ferrite-session = &quot;0.1.4&quot;
...
</code></pre>
<p>To use the constructs provided by Ferrite, import everything from the <code>ferrite_session::prelude</code> module. You'd also need to provide a <code>tokio</code> runtime for Ferrite to spawn its async tasks. This can be done by adding the <code>#[tokio::main]</code> attribute to your main function.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use ferrite_session::prelude::*;

#[tokio::main]
async fn main() { ... }
</code></pre></pre>
<p>Next, we will learn how to use Ferrite to write a simple hello world program.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<p>In this chapter we will look at two simple programs that implement
hello world in Ferrite.</p>
<h2><a class="header" href="#hello-protocol" id="hello-protocol">Hello Protocol</a></h2>
<p>A session type, a.k.a. a protocol, describes a communication protocol between
two parties: a <em>provider</em> and a <em>client</em>. The provider <em>offers</em> a service
as described by the session type, and the client <em>consumes</em> the provided
service in a linear fashion.</p>
<p>In this example, we will define a simple <code>Hello</code> protocol that has
the session type <code>SendValue&lt;String, End&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Hello = SendValue&lt;String, End&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>Hello</code> protocol pretty much self describe the communication protocol:
The provider would send a Rust <code>String</code> value and then terminates. Conversely,
a client for <code>Hello</code> would <em>receive</em> a Rust <code>String</code> value, and then <em>waits</em>
for the provider to terminate.</p>
<p>The type <code>SendValue&lt;T, A&gt;</code> defines a session type that sends a Rust value
<code>T</code>, and then continues with the <em>continuation</em> session type <code>A</code>. The type
<code>End</code> defines a session type that simply terminates. When we combine both
<code>SendValue</code> and <code>End</code> to get <code>SendValue&lt;String, End&gt;</code>, we are effectively
defining a session type that sends a Rust value of type <code>String</code>, and then
<em>continues</em> as session type <code>End</code>, which happens to simply terminates.</p>
<h2><a class="header" href="#hello-world-provider" id="hello-world-provider">Hello World Provider</a></h2>
<p>We first look at how a provider for the <code>Hello</code> protocol can be implemented:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_provider: Session&lt;Hello&gt; =
    send_value(&quot;Hello World!&quot;.to_string(), terminate());
<span class="boring">}
</span></code></pre></pre>
<p>In the above example, we define a variable named <code>hello_provider</code>
with the Rust type <code>Session&lt;Hello&gt;</code>. The Rust type <code>Session&lt;A&gt;</code> denotes
a Ferrite program that is providing a session type <code>A</code>. In this case,
<code>hello_provider</code> is a Ferrite program that provides the <code>Hello</code> protocol.</p>
<p>In the body of <code>hello_provider</code>, we use the Ferrite functions <code>send_value</code> and
<code>terminate</code> to build up our Ferrite program. According to the <code>Hello</code> protocol,
the first step <code>hello_provider</code> needs to do is to send a <code>String</code> value.
To do that, we create a Rust string <code>&quot;Hello World!&quot;.to_string()</code>, and then send
it by calling <code>send_value(&quot;Hello World!&quot;.to_string(), ... )</code>.</p>
<p>Other than the <code>&quot;Hello World!&quot;</code> string in the first argument, <code>send_value</code> also
expects a <em>second</em> argument, which is the <em>continuation</em> after our string value
is sent. In our case, The continuation session type of <code>SendValue&lt;String, End&gt;</code>
is <code>End</code>. As such, there is nothing left to do other than terminating the Ferrite
program, which we can do it by calling <code>terminate()</code>.</p>
<h2><a class="header" href="#run-session" id="run-session">Run Session</a></h2>
<p>Up to this point, we have only defined a Ferrite program named <code>hello_provider</code>,
but we have not yet execute the program. To run it, we would typically need to
pair it with a client that <em>consumes</em> the offered protocol <code>Hello</code>. However
Ferrite provides a special case for Ferrite programs that offer the session types
<code>SendValue&lt;T, End&gt;</code>. So we can run our <code>hello_provider</code> by calling
<code>run_session_with_result</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let result: String = run_session_with_result(hello_provider).await;

  println!(&quot;{}&quot;, result);
<span class="boring">}
</span></code></pre></pre>
<p>Ferrite provides <code>run_session_with_result</code> as a default way of handling
Ferrite programs offering the session type <code>SendValue&lt;T, End&gt;</code>,
because they are trivial to handle.
This can be done by receiving the Rust value sent from the provider,
waits for the provider to terminate, and then returns to the caller.
The function is an async function, so we have to use the <code>.await</code>
syntax to wait for Ferrite to run the program and return the results.</p>
<p>After getting the result back, we can print the received string using
<code>println!</code>, and we can expect <code>&quot;Hello World!&quot;</code> to be printed at this point.</p>
<h2><a class="header" href="#full-hello-world-program" id="full-hello-world-program">Full Hello World Program</a></h2>
<p>Putting everything together, our first hello world program is written as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">use ferrite_session::prelude::*;

type Hello = SendValue&lt;String, End&gt;;

#[tokio::main]
async fn main()
{
  let hello_provider: Session&lt;Hello&gt; =
    send_value(&quot;Hello World!&quot;.to_string(), terminate());

  let result: String = run_session_with_result(hello_provider).await;

  println!(&quot;{}&quot;, result);
}
</code></pre></pre>
<p>Our Rust program defines an async <code>main</code> function using the <code>#[tokio::main]</code>
attribute provided by <code>tokio</code>. Inside the main body, we define our provider
Ferrite program as <code>hello_provider</code>, and then immediately run it using
<code>run_session_with_result</code>. Finally we get back the result string and print it
to the terminal.</p>
<h1><a class="header" href="#client-communication" id="client-communication">Client Communication</a></h1>
<p>In the previous chapter, we defined a hello provider and then run it
immediately using <code>run_session_with_result</code>. However in practical applications,
our Ferrite programs will typically have more complex session types, and
we would want to run multiple programs in parallel that communicate with
each others.</p>
<p>To demonstrate that, instead of running <code>hello_provider</code> directly, we can
define a <code>hello_client</code> that <em>communicates</em> with a provider of the <code>Hello</code>
protocol, and then link it with <code>hello_provider</code>.</p>
<p>First, we define <code>hello_client</code> to have the following type:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; = ...
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>hello_client</code> has the Rust type <code>Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt;</code>,
indicating that it is a Ferrite program offering the session type
<code>ReceiveChannel&lt;Hello, End&gt;</code>. Here we encounter a new session type in the form
<code>ReceiveChannel&lt;A, B&gt;</code>, which is used to <em>receive a channel</em> of session type
<code>A</code> offered by some provider, and then continue offering session type <code>B</code>.</p>
<h2><a class="header" href="#channels" id="channels">Channels</a></h2>
<p>Ferrite allows sending and receiving of <em>channels</em>, which represent the client
end point to communicate with a provider that offers the channel's session type.
At high level, we can think of receiving a channel using <code>ReceiveChannel&lt;A, B&gt;</code>
is similar to plain Rust functions with function traits like <code>FnOnce(A) -&gt; B</code>.
In other words, <code>ReceiveChannel</code> is the equivalent of function types in Ferrite.</p>
<p>There is however one important distinction of <code>ReceiveChannel</code> from regular
Rust functions. That is channels received from <code>ReceiveChannel</code> must be
used <em>linearly</em>, i.e. they cannot be ignored or dropped.
We will revisit this property in later chapters to see why linearity is
important, and why bare Rust code is not sufficient to support linearity.</p>
<p>Now back to our <code>hello_client</code> example. The session type
<code>ReceiveChannel&lt;Hello, End&gt;</code> indicates that <code>hello_client</code> is <em>receiving</em>
a channel of session type <code>Hello</code>, and then terminates with <code>End</code>.
To implement such a session type, we can implement <code>hello_client</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
    receive_channel(|a| {
      receive_value_from(a, move |greeting| {
        println!(&quot;Received greetings from provider: {}&quot;, greeting);
        wait(a, terminate())
      })
    });
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>hello_client</code> body looks slightly more complicated than <code>hello_provider</code>.
To understand what's going on, we will go through each line of
<code>hello_client</code>'s body. Starting with <code>receive_channel</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>receive_channel(|provider| { ... })
<span class="boring">}
</span></code></pre></pre>
<p>To match the final session type <code>ReceiveChannel&lt;Hello, End&gt;</code> that is
offered by <code>hello_client</code>, we use <code>receive_channel</code> to receive a
channel of session type <code>Hello</code>, and then binds it to the <em>channel variable</em>
<code>a</code>. This is similar to a Rust function accepting an argument
and bind it to a variable.</p>
<p>Inside the continuation <code>...</code>, since we have received the <code>Hello</code> channel
already, we will continue to offer the session type <code>End</code>.  To do that,
we just need to eventually terminate <code>hello_client</code>. However we cannot
terminate <code>hello_client</code> just yet, because the channel variable <code>a</code>
is <em>linear</em>, and we must fully consume it before we can terminate.</p>
<p>Recall that <code>Hello</code> is a type alias, so the actual session type of
the channel variable <code>a</code> is <code>SendValue&lt;String, End&gt;</code>.
But instead of having to offer that, we are acting as the <em>client</em>
to consume the session type <code>SendValue&lt;String, End&gt;</code>. Since the provider
is expected to send a <code>String</code> value, as a client we are expected to
<em>receive</em> a <code>String</code> value from the provider. We can do that using
<code>receive_value_from</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>receive_value_from(provider, move |greeting| {
  println!(&quot;Received greetings from provider: {}&quot;, greeting);
  ...
})
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>receive_value_from</code> to receive a value sent from the <code>a</code>
channel, and then bind the received <code>String</code> value to the Rust variable
<code>greeting</code>. We then print out the value of <code>greeting</code> using <code>println!</code>.
Following that, in the continuation <code>...</code>, the session type
of <code>a</code> <em>changes</em> from <code>SendValue&lt;String, End&gt;</code> to
become <code>End</code>.</p>
<p>Unlike regular Rust variables, each time we interacts with a channel
variable, the session type of the channel variable is <em>updated</em>
to its continuation session type. Since Ferrite channels are linear,
we have to continuously interact with the channel until it is
fully terminated.</p>
<p>After calling <code>receive_value_from</code>, we have the channel variable
<code>a</code> with session type <code>End</code>, and we need to offer the session
type <code>End</code> by terminating. But we can't terminate just yet, because
<code>End</code> simply indicates that the provider will eventually terminates,
but may not yet been terminated. Hence we would first have to wait
for <code>a</code> to terminate using <code>wait</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait(provider, terminate())
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>wait</code> to wait for the provider on the other side of a
channel to terminate. After that, the <code>a</code> channel is discarded,
and we don't have anymore unused channel variable. With that, we
can finally terminate our program using <code>terminate()</code>.</p>
<h2><a class="header" href="#linking-provider-with-client" id="linking-provider-with-client">Linking Provider With Client</a></h2>
<p>We have now defined a <code>hello_client</code> program that can accept channel
from any provider offering the session type <code>Hello</code>.
In theory, we can call <code>hello_client</code> with any provider that offers
<code>Hello</code>, not just <code>hello_provider</code>.</p>
<p>To link <code>hello_client</code> specifically with <code>hello_provider</code>, we have to
explicitly ask Ferrite to perform the linking. This can be done
using <code>apply_channel</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let main: Session&lt;End&gt; = apply_channel(hello_client, hello_provider);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>apply_channel</code> construct is provided by Ferrite to link a
client Ferrite program of session type <code>ReceiveChannel&lt;A, B&gt;</code>
with a provider Ferrite program of session type <code>A</code>,
resulting in a new Ferrite program of session type <code>B</code>
as the result.</p>
<p>We can think of the form <code>apply_channel(f, x)</code> as being similar similar to
regular function application in the form <code>f(x)</code>. With <code>f</code> having the Rust type
<code>FnOnce(A) -&gt; B</code> and <code>x</code> having the Rust type <code>A</code>, the result type of applying
<code>x</code> to <code>func</code> would be <code>B</code>.</p>
<h2><a class="header" href="#run-session-1" id="run-session-1">Run Session</a></h2>
<p>After applying <code>hello_provider</code> to <code>hello_client</code>, we now have a single <code>main</code>
program. When <code>main</code> is executed, it will run both <code>hello_provider</code> and
<code>hello_client</code> in parallel, and establish a communication channel between
the two processes.</p>
<p>Since <code>main</code> has the session type <code>End</code>, we can use the Ferrite construct
<code>run_session</code> to run the program:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  run_session(main).await;
<span class="boring">}
</span></code></pre></pre>
<p><code>run_session</code> accepts any Ferrite program offering the session type <code>End</code>,
executes the program, and wait for it to terminate. <code>run_session</code> is
similar to <code>run_session_with_result</code>, other than it does not expect
the Ferrite program to send back any Rust value as the result.</p>
<h2><a class="header" href="#full-program" id="full-program">Full Program</a></h2>
<p>Putting everything together, we now have our second hello world program
that is made of a <code>hello_provider</code> and a <code>hello_client</code> communicating
with each others.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use ferrite_session::prelude::*;

type Hello = SendValue&lt;String, End&gt;;

#[tokio::main]
async fn main()
{
  let hello_provider: Session&lt;Hello&gt; =
    send_value(&quot;Hello World!&quot;.to_string(), terminate());

  let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
    receive_channel(|a| {
      receive_value_from(a, move |greeting| {
        println!(&quot;Received greetings from provider: {}&quot;, greeting);
        wait(a, terminate())
      })
    });

  let hello_client_partial: PartialSession&lt;
    HList![SendValue&lt;String, End&gt;],
    End,
  &gt; = receive_value_from(Z, move |greeting| {
    println!(&quot;Received greetings from provider: {}&quot;, greeting);
    wait(Z, terminate())
  });

  let main: Session&lt;End&gt; = apply_channel(hello_client, hello_provider);

  run_session(main).await;
}
</code></pre></pre>
<h1><a class="header" href="#type-errors" id="type-errors">Type Errors</a></h1>
<p>The way we write a Ferrite program is quite different from how we typically
write a Rust program. This is because Ferrite makes use of Rust's type system
to provide additional safeguard on how session type channels can be used.</p>
<p>We can take a quick look of some error messages raised when our Ferrite
programs are written incorrectly.</p>
<h2><a class="header" href="#an-incorrect-hello-provider" id="an-incorrect-hello-provider">An Incorrect Hello Provider</a></h2>
<p>Let's consider the <code>hello_provider</code> program that we have written in the
previous chapter:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_provider: Session&lt;Hello&gt; =
    send_value(&quot;Hello World!&quot;.to_string(), terminate());
<span class="boring">}
</span></code></pre></pre>
<p>According to the <code>Hello</code> protocol, <code>SendValue&lt;String, End&gt;</code>,
<code>hello_provider</code> is supposed to send a string value before terminating.
But what if we implement <code>hello_provider</code> such that it terminates
immediately without sending a string?</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_provider_incorrect: Session&lt;Hello&gt; = terminate();
<span class="boring">}
</span></code></pre></pre>
<p>In this case, if we try to compile our program, we would get a compile
error from Rust showing a message similar to as follows:</p>
<pre><code>error[E0308]: mismatched types
 |   let hello_provider_incorrect: Session&lt;Hello&gt; = terminate();
 |                                 --------------   ^^^^^^^^^^^ expected struct `ferrite_session::prelude::SendValue`, found struct `ferrite_session::prelude::End`
 |                                 |
 |                                 expected due to this
 |
 = note: expected struct `PartialSession&lt;(), ferrite_session::prelude::SendValue&lt;String, ferrite_session::prelude::End&gt;&gt;`
            found struct `PartialSession&lt;_, ferrite_session::prelude::End&gt;`
</code></pre>
<p>The error message above has been slightly prettified to make it more readable,
but the content remains the same. First of all, we see that the error is about
type mismatch between a <code>PartialSession</code> type, which we will cover in a
<a href="01-getting-started/../03-main-concepts/03-partial-sessions.html">later chapter</a>.</p>
<p>Inside the second type parameter of <code>PartialSession</code>, notice that
there is a mismatch between the expected session type
<code>SendValue &lt; String, End &gt;</code>, and the actual session type <code>End</code>. From that,
we can deduce that <code>hello_provider_incorrect</code> has violated the <code>Hello</code>
protocol, by instead offering the protocol <code>End</code>.</p>
<h2><a class="header" href="#an-incorrect-hello-client" id="an-incorrect-hello-client">An Incorrect Hello Client</a></h2>
<p>The error message we get from <code>hello_provider_incorrect</code> is relatively simple,
as the type mismatch is on the offered channel. On the other hand, recall that
<code>hello_client</code> deals with <em>two</em> channels: one with the receiver end of <code>Hello</code>,
and one that offers the session type <code>End</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
    receive_channel(|a| {
      receive_value_from(a, move |greeting| {
        println!(&quot;Received greetings from provider: {}&quot;, greeting);
        wait(a, terminate())
      })
    });
<span class="boring">}
</span></code></pre></pre>
<p>Based on the protocol specification, it looks like <code>hello_client</code> should be able
to receive a <code>Hello</code> channel, ignores the channel, and proceed to terminate
immediately. So let's try implementing a new client to do just that:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client_incorrect: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
  receive_channel(|provider| {
    terminate()
  });
<span class="boring">}
</span></code></pre></pre>
<p>In <code>hello_client_incorrect</code>, the <code>provider</code> channel is ignored after we have received
it, and we proceed to call <code>terminate</code> immediately. If we try to build this,
we would instead get the following compile error:</p>
<pre><code>error[E0277]: the trait bound `(ferrite_session::prelude::SendValue&lt;String, ferrite_session::prelude::End&gt;, ()): ferrite_session::internal::base::EmptyContext` is not satisfied
 |
 |     terminate()
 |     ^^^^^^^^^ the trait `ferrite_session::internal::base::EmptyContext` is not implemented for `(ferrite_session::prelude::SendValue&lt;String, ferrite_session::prelude::End&gt;, ())`
 |
 |
 |   C: EmptyContext,
 |      ------------ required by this bound in `ferrite_session::prelude::terminate`
 |
 = help: the following implementations were found:
           &lt;(ferrite_session::prelude::Empty, R) as ferrite_session::internal::base::EmptyContext&gt;
</code></pre>
<p>The error can look a bit scary, but it mainly boils down to two constructs:
a new type <code>(SendValue&lt;String, End&gt;, ())</code> and a new trait <code>EmptyContext</code>.</p>
<p>The type <code>(SendValue&lt;String, End&gt;, ())</code> represents the <em>linear context</em> in
<code>hello_client_incorrect</code>, when the expression <code>terminate()</code> is called. We will
cover the details of linear context in a
<a href="01-getting-started/../03-main-concepts/02-linear-context.html">later chapter</a>. For now it is sufficient
to know that it is used to track the <code>provider</code> channel we have just received,
and it has the session type <code>SendValue&lt;String, End&gt;</code>.</p>
<p>The <code>EmptyContext</code> trait is essentially telling us that in order to use the
<code>terminate()</code> construct, the current linear context must be empty.
However because we have not yet used up the <code>provider</code> channel, the
linear context is thus not empty, and so we cannot terminate just yet.</p>
<h2><a class="header" href="#enforcing-linear-usage-at-compile-time" id="enforcing-linear-usage-at-compile-time">Enforcing Linear Usage at Compile Time</a></h2>
<p>The error from <code>hello_client_incorrect</code> shows us how Ferrite enforces linear
usage of session type channels at compile time. This can greatly reduce the
chance of us writing incorrect Ferrite programs that just abort in the
middle of communicating with other processes.</p>
<p>The linear usage of Ferrite channels is different from the <em>affine</em> usage
of Rust objects. Consider an equivalent of <code>hello_client</code> implemented
using <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html">Rust channels</a>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello_client_rust(receiver: Receiver&lt;String&gt;) {
  // drops receiver immediately
}
<span class="boring">}
</span></code></pre></pre>
<p>In standard Rust programs, we establish communication between concurrent
processes by explicitly passing the sender or receiver end of a Rust channel
as function argument. However since the Rust channel is just an affine
Rust object, it is possible that one party drops the channel half way,
intentionally or not.</p>
<p>In the simple case of our <code>Hello</code> protocol, the dropping of a channel
might not seem critical. But what if the protocol is slightly more complicated?</p>
<p>Let's say we have an <code>Ping</code> protocol with the session type
<code>ReceiveValue&lt;String, SendValue&lt;String, End&gt;&gt;</code>. This would require the
provider to receive a string value before sending back another string value,
and vice versa for the client. If a client drops the channel without
sending a value to the provider, the provider would potentially wait forever
without receiving the string.</p>
<p>Even if the provider can somehow detect that the client has dropped the
channel half way, it would still have to raise a runtime error to signal
the error on protocol violation. We would then have to write a lot of
tests to make sure such errors never happen in practice. Even so the
tests may not be exhaustive enough to cover all corner cases.</p>
<p>By enforcing the linear usage of channels at compile time, Ferrite helps
eliminate a broad range of communication errors that can happen due to
incorrect implementations. As we will see in later chapters, using Ferrite
we can safely implement complex communication protocols in our Rust programs,
without having to worry about our programs not correctly following
these protocols.</p>
<h1><a class="header" href="#session-types" id="session-types">Session Types</a></h1>
<p>This chapter provides some supplementary overview of session types,
the type theory that Ferrite is based on. In the discussion we
will talk about some concepts related to
<a href="https://en.wikipedia.org/wiki/Mathematical_logic">logic</a> and
<a href="https://en.wikipedia.org/wiki/Type_theory">type theory</a>.
For readers who are unfamiliar with these topics, feel free
to skip this chapter and move on to the
<a href="01-getting-started/./06-macros.html">next chapter</a>.</p>
<h2><a class="header" href="#background-on-session-types" id="background-on-session-types">Background on Session Types</a></h2>
<p>So far we have been talking about session types without going into details
what it is. Broadly speaking, session types can refer to a branch of
type systems used to model structured communication-based
programming. Session types are also known as <em>behavioural types</em>, since
the types describe the behaviour of a program.</p>
<p>From the theoretical perspective, session types establish a
<a href="https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence">correspondence</a>
with <a href="https://plato.stanford.edu/entries/logic-linear/">linear logic</a>.
This makes session-typed languages slightly different from functional
languages such as Rust and Haskell, which have their roots in
<a href="https://plato.stanford.edu/entries/lambda-calculus/">lambda calculus</a>
and
<a href="https://plato.stanford.edu/entries/logic-intuitionistic/">intuitionistic logic</a>.</p>
<p>Throughout this book, we will learn about various concepts of session types
from the perspective of a Rust programmer. While this may not be a comprehensive
overview of session types themselves, we aim to cover enough of the basics
so that you can explore more deeply into session types through other resources.</p>
<h2><a class="header" href="#linear-affine-and-structural-rules" id="linear-affine-and-structural-rules">Linear, Affine, and Structural Rules</a></h2>
<p>One notable distiction between session types and Rust is that session typed
variables are <em>linear</em>, while Rust variables are <em>affine</em> by default.
We will try to understand what that really means.</p>
<p>A common explanation of linear vs affine is that linear variables must be
used exactly once, while affine variables can be used at most once.
However that is not entirely accurate.</p>
<p>To be more precise, type theorists differentiate different kinds of
type systems based on which
<a href="https://en.wikipedia.org/wiki/Structural_rule">structural rules</a>
are allowed in the type system:</p>
<ul>
<li>
<p>In a normal type system like Haskell, variables are allowed to be used
more than once (contraction). Variables are also allowed to be discarded
(weakening).</p>
</li>
<li>
<p>In an affine type system like Rust, variables are <em>not</em> allowed to be used
more than once (no contraction), unless they specifically implement
<code>Copy</code> or <code>Clone</code>.
However variables are still allowed to be discarded (weakening).</p>
</li>
<li>
<p>In a linear type system like Ferrite, variables are <em>not</em> allowed to be
used more than once (no contraction), and variables are <em>not</em> allowed to
be discarded (no weakening).</p>
</li>
</ul>
<p>As we have seen in the previous chapter, Ferrite programs like <code>hello_client</code>
interact with channel variables multiple times, with the session type of
the channel changing every time after interaction. Under linear typing rules,
we cannot make multiple copies of the channel, and we also cannot discard
the channel until it is explicitly terminated.</p>
<h2><a class="header" href="#intuitionistic-vs-classical-linear-logic" id="intuitionistic-vs-classical-linear-logic">Intuitionistic vs Classical Linear Logic</a></h2>
<p>Since session types cover a family of programming languages, readers with
some familiarity with session types may notice that Ferrite's implementation
is quite different from some other session types implementations in the wild,
such as <a href="https://github.com/Munksgaard/session-types">session-types</a>
and <a href="https://github.com/wenkokke/sesh">sesh</a>.</p>
<p>Ferrite's implementation of session types is based on
<em>intuitionistic</em> linear logic. This is in contrast with the <em>classical</em>
linear logic formulation that is used by some other session types
implementations.</p>
<p>From the programmers' perspective, there are some key differences when
using the intuitionistic formulation of session types in Ferrite.
For example, you may notice that there is no need for <em>dualization</em>
in Ferrite. This means that the session type signature remain the
same from the perspective of both the provider and the client.</p>
<p>As illustrated in the <a href="01-getting-started/./03-communication.html">previous chapter</a>,
while the provider <code>hello_provider</code> sends a string value through
a channel with the session type <code>SendValue&lt;String, End&gt;</code>,
the client <code>hello_client</code> <em>receives</em> a value from a channel of the
same session type.</p>
<p>In comparison, with classical formulation, we would instead
have to explicitly dualize the session type. As a result,
the session type of the channel given to <code>hello_client</code> would
instead have the session type <code>ReceiveValue&lt;String, End&gt;</code>.</p>
<p>Both intuitionistic and classical formulation of session types
share the same foundation, viewed from different angles.
From the perspective of a type theorist, it may be more
convenient to formulate proofs with the help of dualization
in the classical formulation.</p>
<p>From the perspective of a programmer, it may be more intuitive to understand
session types in the intuitionistic formulation. Intuitionistic session types
have closer semantics with lambda calculus, and this makes it easier for
programmers to bridge the concepts with their existing knowledge in
functional programming.</p>
<p>We leave it to informed readers to decide whether the intuitionistic formulation
of Ferrite provides better intuition for programming in session types.
For the purpose of this book, it is only important for us to clarify
the distinctions, so that readers are better informed when comparing
Ferrite with other session types implementations.</p>
<h2><a class="header" href="#learn-more" id="learn-more">Learn More</a></h2>
<p>If you are interested to learn more about session types, there are
a wealth of type theoretic resources available. To get started,
we recommend the following learning materials by our co-author:</p>
<ul>
<li>
<p>Tutorial slides - <a href="http://www.cs.cmu.edu/%7Ebalzers/publications/session_typed_concurrent_programming.pdf">Session-Typed Concurrent Programming</a></p>
</li>
<li>
<p>OPLSS video lectures - <a href="https://www.youtube.com/watch?v=xYhGY0Lq8cw&amp;list=PL0DsGHMPLUWWyBBTpnTBKsYxdkbIoy1q8">Session-Typed Concurrent Programming</a></p>
</li>
</ul>
<p>Other than that, the research group <a href="http://groups.inf.ed.ac.uk/abcd/index.html">ABCD</a>
also publishes a comprehensive list of resources related to
session types, including a list of
<a href="http://groups.inf.ed.ac.uk/abcd/session-implementations.html">session types implementations</a>.</p>
<h1><a class="header" href="#main-concepts" id="main-concepts">Main Concepts</a></h1>
<p>In this section, we will explore some of the core concepts of Ferrite.
The constructs in Ferrite follow closely with the concepts in session types,
with some slight differences that will be addressed here.</p>
<h1><a class="header" href="#protocols" id="protocols">Protocols</a></h1>
<p>Ferrite uses the term <em>protocol</em> to refer to session types in Rust. All protocol in Ferrite implements the
<code>Protocol</code> trait. The name of the protocols are defined based on the behavior of the provider.
Most of the Ferrite protocols also contain <em>continuation</em> protocols, which describe the protocol that
follows after the current protocol have been executed.</p>
<p>We have seen an example protocol in the <a href="02-main-concepts/../01-getting-started/02-hello-world.html">previous section</a>,
<code>SendValue&lt;String, End&gt;</code>. This means that the type <code>SendValue&lt;String, End&gt;</code> implements the <code>Protocol</code> trait.
This is so because <code>End</code> is a protocol representing termination, and the type <code>SendValue&lt;T, A&gt;</code> is a protocol
if the <em>continuation</em> protocol <code>A</code>, which is <code>End</code> in this case, is a protocol. The type <code>SendValue&lt;String, End&gt;</code>
describes a protocol which the provider sends a <code>String</code> value and then terminates with <code>End</code>. On the other end,
this behavior is inversed, with the client <em>receives</em> the <code>String</code> value and then <em>waits</em> for the provider to terminate.</p>
<p>For a Rust type to be a Ferrite protocol. It has to follow certain conditions. For example, while we can define a Rust type
like <code>SendValue&lt;String, i32&gt;</code>, it is not considered by Ferrite to be a protocol. This is because the continuation
type <code>i32</code> does not implement <code>Protocol</code>. Therefore <code>SendValue&lt;String, i32&gt;</code> also does not implement <code>Protocol</code>.</p>
<p>Some protocols also have additional constraints that need to be satisfied. For example, the protocol <code>SendValue&lt;T, A&gt;</code>
also requires the Rust value to be send, <code>T</code>, to implement <a href="https://doc.rust-lang.org/std/marker/trait.Send.html"><code>Send</code></a> and <code>'static</code>.
This means that we can only send Rust values that can be safely transferred across threads, and do not contain other local lifetimes.</p>
<p>Using Ferrite, we can define complex protocols that have many layers of nested continuations.
For example, the protocol <code>SendValue&lt;String, ReceiveValue&lt;i32, SendValue&lt;bool, End&gt;&gt;&gt;</code>
describes a session type which the provider first sends a <code>String</code> value, then receives
an <code>i32</code> value, then sends a <code>bool</code> value, before finally terminating.</p>
<h2><a class="header" href="#overview-of-linear-protocols-in-ferrite" id="overview-of-linear-protocols-in-ferrite">Overview of Linear Protocols in Ferrite</a></h2>
<p>We will cover in detail each protocol in the upcoming chapters. Below shows a summary of protocols available in Ferrite:</p>
<table><thead><tr><th>Protocol</th><th>Provider Description</th></tr></thead><tbody>
<tr><td><a href="02-main-concepts/../03-basic-constructs/01-termination.html"><code>End</code></a></td><td>Termination</td></tr>
<tr><td><a href="02-main-concepts/../03-basic-constructs/02-send-receive-values.html"><code>SendValue&lt;T, A&gt;</code></a></td><td>Send a Rust value of type <code>T</code>, and continue as session type <code>A</code></td></tr>
<tr><td><a href="02-main-concepts/../03-basic-constructs/02-send-receive-values.html"><code>ReceiveValue&lt;T, A&gt;</code></a></td><td>Receive a Rust value of type <code>T</code>, and continue as session type <code>A</code></td></tr>
<tr><td><a href="02-main-concepts/../03-basic-constructs/03-send-receive-channels.html"><code>SendChannel&lt;A, B&gt;</code></a></td><td>Send a channel of session type <code>A</code>, and continue as session type <code>B</code></td></tr>
<tr><td><a href="02-main-concepts/../03-basic-constructs/03-send-receive-channels.html"><code>ReceiveChannel&lt;A, B&gt;</code></a></td><td>Receive a channel of session type <code>A</code>, and continue as session type <code>B</code></td></tr>
<tr><td><a href="02-main-concepts/../03-basic-constructs/04-external-choice.html"><code>ExternalChoice&lt;Choice&gt;</code></a></td><td>Provide the client with choices defined in <code>Choice</code></td></tr>
<tr><td><a href="02-main-concepts/../03-basic-constructs/05-internal-choice.html"><code>InternalChoice&lt;Choice&gt;</code></a></td><td>Offer a particular choice defined in <code>Choice</code></td></tr>
<tr><td><a href="02-main-concepts/../04-advanced-constructs/01-recursive-session-types.html"><code>Rec&lt;F&gt;</code></a></td><td>Recursive session type, with <code>F</code> being a session type containing recursion markers such as <code>Z</code>.</td></tr>
</tbody></table>
<h1><a class="header" href="#linear-context" id="linear-context">Linear Context</a></h1>
<p>A Ferrite program offers exactly one protocol, as denoted by the type <code>Session&lt;A&gt;</code>, with
<code>A</code> being the provided protocol. For example, when we define our
<a href="02-main-concepts/../01-getting-started/02-hello-world.html"><code>hello_provider</code></a> program
that offers <code>SendValue&lt;String, End&gt;</code>, the type of the program is <code>Session&lt;SendValue&lt;String, End&gt;&gt;</code>.
When we implement <code>hello_provider</code> as <code>send_value(&quot;Hello World!&quot;.to_string(), terminate())</code>,
we are implicitly sending the string value <code>&quot;Hello World!&quot;</code> to the <em>offered</em> channel
of the protocol <code>SendValue&lt;String, End&gt;</code>.</p>
<p>Although a Ferrite program can only have one offered channel, it can also interact with
other Ferrite programs and act as the <em>client</em> of the offered channels. Since there
can be more than one client channels available, we need to identify the different
channels available using <em>channel variables</em>.
So in the case of <a href="02-main-concepts/../01-getting-started/03-communication.html"><code>hello_client</code></a>,
we bind the channel variable <code>a</code> to the client channel of protocol
<code>SendValue&lt;String, End&gt;</code>, so that it can <em>receive</em> a string value from the provider.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
    receive_channel(|a| {
      receive_value_from(a, move |greeting| {
        println!(&quot;Received greetings from provider: {}&quot;, greeting);
        wait(a, terminate())
      })
    });
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#type-level-list" id="type-level-list">Type Level List</a></h2>
<p>Ferrite tracks the linear usage of channel variables in a <em>linear context</em>.
A linear context is encoded as a Rust type containing zero or more protocols,
in the form of a <em>type level list</em>. We can use the <code>HList!</code> macro to define
a list of Rust types. For example:</p>
<ul>
<li><code>HList![]</code> is an <em>empty</em> type level list.</li>
<li><code>HList![String]</code> is a type level list with just one element, <code>String</code>.</li>
<li><code>HList![String, i32, bool]</code> is a type level list containing 3 Rust types: <code>String</code>, <code>i32</code>, and <code>bool</code>.</li>
<li><code>HList![SendValue&lt;String, End&gt;, ReceiveValue&lt;i32, End&gt;, End]</code> is a type level list containing 3
Ferrite protocols: <code>SendValue&lt;String, End&gt;</code>, <code>ReceiveValue&lt;i32, End&gt;</code>, and <code>End</code>.</li>
</ul>
<p>Behind the scene, the <code>HList!</code> macro desugars a type level list into nested tuples
of the form <code>(A0, (A1, (A2, (..., (An, ())))))</code>. This is similar to how linked lists
are constructed in Lisp. We start by treating the unit type <code>()</code> as the empty list.
To prepend an element <code>A</code> to the front of another list <code>R</code>, we use the tuple constructor
<code>(,)</code> to form the new list <code>(A, R)</code>, with <code>A</code> being the <em>head</em> of the list and <code>R</code>
being the <em>tail</em> of the list. So for example:</p>
<ul>
<li><code>HList![]</code> desugars to <code>()</code>.</li>
<li><code>HList![String]</code> desugars to <code>(String, ())</code>.</li>
<li><code>HList![String, i32, bool]</code> desugars to <code>(String, (i32, (bool, ())))</code>.</li>
<li><code>HList![SendValue&lt;String, End&gt;, ReceiveValue&lt;i32, End&gt;, End]</code> desugars to
<code>(SendValue&lt;String, End&gt;, (ReceiveValue&lt;i32, End&gt;, (End, ())))</code>.</li>
</ul>
<p>When we encounter compile errors while writing Ferrite programs, we can often
see desugared type level lists shown in the error messages. To understand the
error messages, we just need to recognize the patterns and think of them
as being the same as the pretty printed <code>HList![...]</code> elements.</p>
<h2><a class="header" href="#the-context-trait" id="the-context-trait">The <code>Context</code> trait</a></h2>
<p>Ferrite requires linear contexts to implement the <code>Context</code> trait. This is
automatically implemented for a type level list, if all its elements implement
the <code>Protocol</code> trait. So for example:</p>
<ul>
<li><code>HList![]</code> is a valid linear context, and it is an <em>empty</em> context.</li>
<li><code>HList![SendValue&lt;String, End&gt;]</code> is a linear context with one protocol, <code>SendValue&lt;String, End&gt;</code>.</li>
<li><code>HList![SendValue&lt;String, End&gt;, ReceiveValue&lt;i32, End&gt;, End]</code> is a linear context,
because all 3 elements are valid Ferrite protocols.</li>
<li><code>HList![String, i32, bool]</code> is not a linear context, because none of them are valid
Ferrite protocols.</li>
<li><code>HList![SendValue&lt;String, End&gt;, String]</code> is not a linear context, because the
second element <code>String</code> is not a Ferrite protocol.</li>
<li><code>HList![SendValue&lt;String, End&gt;, ReceiveValue&lt;i32, i32&gt;]</code> is not a linear context,
because the second element <code>ReceiveValue&lt;i32, i32&gt;</code> is not a valid Ferrite protocol.</li>
</ul>
<p>All Ferrite program has an associated linear context, and a program usually starts with an
empty linear context <code>HList![]</code>. For the case of <code>hello_client</code>,
in the beginning it also starts with the empty context. When we use <code>receive_channel</code>
inside <code>hello_client</code>, a new channel is then added to the linear context in the continuation.
As a result, the linear context in the continuation after <code>receive_channel</code> becomes
<code>HList![SendValue&lt;String, End&gt;]</code>, with the channel variable <code>a</code> referring to the first
channel <code>SendValue&lt;String, End&gt;</code>.</p>
<h2><a class="header" href="#empty-slots" id="empty-slots">Empty Slots</a></h2>
<p>When a Ferrite program has a non-empty linear context, it would have to fully
consume all linear channels before it can finally terminate. For the case
of <code>hello_client</code>, this would mean that the linear context <code>HList![SendValue&lt;String, End&gt;]</code>
has to be fully consumed. We do that by first receiving the value using
<code>receive_value_from(a, ...)</code>. In the continuation, the linear context would be
updated to become <code>HList![End]</code> after the value is received. At this point
we would then wait for the channel to terminate using <code>wait(a, ...)</code>.</p>
<p>After the channel <code>a</code> is terminated, the original position of the channel
in the linear context is updated with a special <em>empty slot</em> called <code>Empty</code>.
This is used to indicate that the channel has been fully consumed, and
it may be safe for the program to terminate. So in the continuation
after <code>wait(a, ...)</code>, the linear context is updated to become <code>HList![Empty]</code>.</p>
<p>Compared to <code>End</code>, <code>Empty</code> is not a protocol. So we cannot for example define a
Ferrite program  that offers <code>Empty</code>. However <code>Empty</code> is treated as a valid
element in a linear context. So a type level list like
<code>HList![Empty, SendValue&lt;String, End&gt;]</code> also implements <code>Context</code>.</p>
<h2><a class="header" href="#empty-context" id="empty-context">Empty Context</a></h2>
<p>When we call <code>terminate()</code>, Ferrite checks whether a linear context is empty
using the <code>EmptyContext</code> trait. This trait is implemented if the linear context
is an empty list <code>HList![]</code>, or if all elements in the linear context is <code>Empty</code>.
So <code>HList![]</code>, <code>HList![Empty]</code>, <code>HList![Empty, Empty]</code>, and so on all implement
<code>EmptyContext</code>.</p>
<p>When we try to call <code>terminate()</code> with a non-empty linear context,
we will get a compile error stating that the type <code>HList![...]</code> does not
implement <code>EmptyContext</code>. When encountering such error, we can inspect
the list and see which element is not empty, and update our Ferrite
program to fully consume the channel accordingly.</p>
<h1><a class="header" href="#sessions" id="sessions">Sessions</a></h1>
<p>We have seen that Ferrite programs have the Rust type <code>Session&lt;A&gt;</code>, where
the type <code>A</code> must implement the <code>Protocol</code> trait. A Ferrite program
of type <code>Session&lt;A&gt;</code> starts with an empty linear context, and offers
the protocol <code>A</code>. More generally, it is also possible to define <em>partial</em>
Ferrite programs with non-empty linear context. In such cases, these
programs would have the Rust type <code>PartialSession&lt;C, A&gt;</code>.</p>
<h2><a class="header" href="#partial-sessions" id="partial-sessions">Partial Sessions</a></h2>
<p>A partial Ferrite program of type <code>PartialSession&lt;C, A&gt;</code> have a linear
context <code>C</code> which implements <code>Context</code>, and offers the session type <code>A</code>.
The linear context <code>C</code> may be non-empty, and if so the partial program
must fully consume the linear context before it can terminate.</p>
<p>In the special case when the linear context is empty, the partial program
is then equivalent to the full Ferrite program. In fact, the type
<code>Session&lt;A&gt;</code> is defined to be a type alias of <code>PartialSession&lt;(), A&gt;</code>,
or <code>PartialSession&lt;HList![], A&gt;</code>.</p>
<p>When we write our Ferrite program, the program is actually made of
many fragments of <code>PartialSession</code> that are composed together.
For example, the program fragment <code>wait(a, terminate())</code> in
<code>hello_client</code> has the Rust type <code>PartialSession&lt;HList![End], End&gt;</code>,
and the program fragment <code>receive_value_from(a, wait(a, terminate()))</code>
has the Rust type <code>PartialSession&lt;HList![SendValue&lt;String, End&gt;], End&gt;</code>.</p>
<p>Ferrite constructs such as <code>receive_value_from</code> implements the typing
rules of how the linear context and the offered protocol should be
updated before and after the given Ferrite expression. For example,
given that the channel variable <code>a</code> refers to the first element of
the linear context, the Rust expression <code>receive_value_from(a, cont)</code>
should have the type in the form <code>PartialSession&lt;HList![SendValue&lt;T, A&gt;], B&gt;</code>,
and the continuation expression <code>cont</code> should have the Rust type in the form
<code>PartialSession&lt;HList![A], B&gt;</code>. i.e. <code>receive_value_from</code> <em>updates</em>
the protocol of the first channel in the linear context from <code>SendValue&lt;T, A&gt;</code>
to <code>A</code> for any protocol <code>A</code>.</p>
<h2><a class="header" href="#closed-ferrite-programs" id="closed-ferrite-programs">Closed Ferrite Programs</a></h2>
<p>Now that we have learned about <code>PartialSession</code>, a question that might arise is
why don't we just define <code>hello_client</code> to have the type
<code>PartialSession&lt;HList![ReceiveValue&lt;String, End&gt;], End&gt;</code> instead of
<code>Session&lt;ReceiveChannel&lt;ReceiveValue&lt;String, End&gt;, End&gt;&gt;</code>?
The reason is because a partial session has <em>free variables</em> that
are not captured by the program. Consider the following invalid program:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client_incorrect
  : PartialSession&lt;HList![ReceiveValue&lt;String, End&gt;], End&gt;
  = receive_value_from(a, move |greeting| {
      println!(&quot;Received greetings from provider: {}&quot;, greeting);
      wait(a, terminate())
    });
<span class="boring">}
</span></code></pre></pre>
<p>The channel variable <code>a</code> is not defined anywhere, or in other words we
have a free variable <code>a</code>, hence the program would not compile.
We can think of defining partial sessions directly being equivalent
to defining Rust expressions containing free variables such as <code>x + 1</code>.
Without the surrounding code, we wouldn't able to know where <code>x</code> is from
and whether the expression is valid with a given <code>x</code>. To make such
expression to be valid, we would instead define a <em>closure</em> that
captures the free variable <code>x</code>, forming the <em>closed</em> expression
<code>|x| { x + 1 }</code>.</p>
<p>The same principle also applies to Ferrite programs.
In practice, we would write Ferrite programs having the <code>Session</code> type
instead of <code>PartialSession</code> so that there are no free channel variables
that escape the program.</p>
<h1><a class="header" href="#channel-selectors" id="channel-selectors">Channel Selectors</a></h1>
<p>In the code for <a href="02-main-concepts/../01-getting-started/03-communication.html"><code>hello_client</code></a>, we have seen
that the <code>receive_channel</code> construct introduces a new channel variable to our continuation,
which we bind to the variable <code>a</code>. The channel variable <code>a</code> is then used in both
<code>receive_value_from(a, ...)</code> and <code>wait(a, ...)</code> to access the given channel in the linear context.
In this chapter, we will peek a bit into the mechanics of how the channel variables
provide access to channels in the linear context.</p>
<h2><a class="header" href="#context-lenses" id="context-lenses">Context Lenses</a></h2>
<p>Recall from the <a href="02-main-concepts/./02-linear-context.html">previous chapter</a> that a linear context
has the form <code>HList![A0, A1, ...]</code>, with each element implementing <code>Protocol</code>.
During the execution of a Ferrite program, the session type of the channels
in the linear context will be updated in each step, until the final linear
context has the form <code>HList![Empty, Empty, ...]</code> to be safely terminated.</p>
<p>When some Ferrite constructs such as <code>receive_value_from</code> are called, a channel
variable needs to be given so that the construct can know which channel
in the linear context it should access. Since the linear context is represented
as a type level list, the channels are in fact not named in the linear context.
Instead, channel variables such as <code>a</code> in <code>hello_client</code> actually have types
that implement <em>context lenses</em> to access channels in the linear context
by <em>position</em>.</p>
<p>Conceptually, a type <code>N</code> that implements the <code>ContextLens</code> trait provides
access to a particular element in the type level list, and update it
to a new type. For example in <code>hello_client</code>, the type of <code>a</code> implements
<code>ContextLens</code> for accessing the linear contexts
<code>HList![SendValue&lt;String, End&gt;]</code>, and updates it to <code>HList[End]</code>, then
finally updates it to <code>HList![Empty]</code>.</p>
<h2><a class="header" href="#type-level-natural-numbers" id="type-level-natural-numbers">Type Level Natural Numbers</a></h2>
<p>To define types that implement the <code>ContextLens</code> trait, Ferrite uses
<em>type level natural numbers</em> to implement the access to channels
in the type level list by the corresponding position. A type level
natural number starts with the type <code>Z</code>, which corresponds to the
number 0. Following that, we have the type <code>S&lt;Z&gt;</code>, which means
the <em>successor</em> of <code>Z</code>, to correspond to the number 1.
Similarly, we have <code>S&lt;S&lt;Z&gt;&gt;</code> corresponding to the successor of 1,
which is 2, and so on. So we have the types
<code>Z</code>, <code>S&lt;Z&gt;</code>, <code>S&lt;S&lt;Z&gt;&gt;</code>, <code>S&lt;S&lt;S&lt;Z&gt;&gt;&gt;</code>, ... corresponding to
the number sequence 0, 1, 2, 3, ...</p>
<p>For each of the type level natural numbers, Ferrite implements
the <code>ContextLens</code> trait for accessing channels at the corresponding
zero-indexed position in the linear context. So for example:</p>
<ul>
<li>
<p>The type <code>Z</code> can update any linear context in the form <code>HList![A0, ...]</code> to
<code>HList![B, ...]</code>, with the first element <code>A0</code> replaced with <code>B</code> and the
remaining elements unchanged.</p>
</li>
<li>
<p>The type <code>S&lt;Z&gt;</code> can update any linear context in the form <code>HList![A0, A1, ...]</code> to
<code>HList![A0, B, ...]</code>, with the second element <code>A1</code> replaced with <code>B</code> and
the remaining elements unchanged.</p>
</li>
<li>
<p>The type <code>S&lt;S&lt;Z&gt;&gt;</code> can update any linear context in the form <code>HList![A0, A1, A2, ...]</code> to
<code>HList![A0, A1, B, ...]</code>, with the third element <code>A3</code> replaced with <code>B</code> and
the remaining elements unchanged.</p>
</li>
</ul>
<p>As demonstration, we can deduce that the channel variable <code>a</code> in <code>hello_client</code> has
the type <code>Z</code>, because there is only one channel in the linear context and it is
the one that we are interested in. <code>Z</code> implements the <code>ContextLens</code> for updating
the first element in any linear context. So <code>receive_channel_from</code> can use <code>Z</code>
to update the linear context from <code>HList![ReceiveValue&lt;String, End&gt;]</code> to <code>HList![End]</code>,
and it can also use <code>Z</code> to update the linear context from <code>HList![End]</code> to <code>HList![Empty]</code>.</p>
<h2><a class="header" href="#the-contextlens-trait" id="the-contextlens-trait">The <code>ContextLens</code> Trait</a></h2>
<p>The full definition of the <code>ContextLens</code> trait is in the form <code>ContextLens&lt;C1, A, B, Target=C2&gt;</code>.
It means that a type <code>N</code> that implements <code>ContextLens&lt;C1, A, B, Target=C2&gt;</code> provides
the operation to access a channel of session type <code>A</code> that can be found in <code>C1</code>,
update it to <code>B</code>, and result in the new context <code>C2</code>. This can be elaborated with
the implementations by the natural numbers:</p>
<ul>
<li>
<p><code>Z: ContextLens&lt;HList![A0, ...], A0, B, Target=HList![B, ...]&gt;</code></p>
</li>
<li>
<p><code>S&lt;Z&gt;: ContextLens&lt;HList![A0, A1, ...], A0, B, Target=HList![A0, B, ...]&gt;</code></p>
</li>
<li>
<p><code>S&lt;S&lt;Z&gt;&gt;: ContextLens&lt;HList![A0, A1, A2,...], A0, B, Target=HList![A0, A1, B, ...]&gt;</code></p>
</li>
</ul>
<p>Following the above template, we can know that in the case of <code>hello_client</code>, the type <code>Z</code>
does implements the required <code>ContextLens</code> traits:</p>
<ul>
<li>
<pre><code>Z: ContextList&lt;
      HList![ReceiveValue&lt;String, End&gt;],
      ReceiveValue&lt;String, End&gt;,
      End,
      Target=HList![End]&gt;
</code></pre>
</li>
<li>
<pre><code>Z: ContextList&lt;
      HList![End],
      End,
      Empty,
      Target=HList![Empty]&gt;
</code></pre>
</li>
</ul>
<h2><a class="header" href="#writing-partial-ferrite-programs" id="writing-partial-ferrite-programs">Writing Partial Ferrite Programs</a></h2>
<p>Now that we know how context lenses are actually implemented, it would in fact
be possible for us to write partial Ferrite programs of type <code>PartialSession</code>,
by hard coding the specific context lenses to access the channels in the linear context.
For example, we could have written a partial version of <code>hello_client</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client_partial: PartialSession&lt;
    HList![SendValue&lt;String, End&gt;],
    End,
  &gt; = receive_value_from(Z, move |greeting| {
    println!(&quot;Received greetings from provider: {}&quot;, greeting);
    wait(Z, terminate())
  });
<span class="boring">}
</span></code></pre></pre>
<p>While writing such program is possible, the code is not ergonomic and is generally
not recommended. This is because we are hardcoding the position of the channels
in the linear context, instead of using meaningful identifiers. This would also
reduce readability and makes it more difficult to add or remove channels to
the program.</p>
<p>This style of programming using the position is similar to programming using
<a href="https://en.wikipedia.org/wiki/De_Bruijn_index">De Bruijn index</a>. While this
is useful for internal implementation, we as programmers tend to prefer
using named variables to improve readability and better structure our code.</p>
<h2><a class="header" href="#type-errors-using-context-lenses" id="type-errors-using-context-lenses">Type Errors Using Context Lenses</a></h2>
<p>When we write Ferrite programs that contain invalid access to channels in the linear context,
we may get compile errors showing that types like <code>Z</code> do not implement a particular context lens.
As an example, consider the following incorrect version of <code>hello_client</code> that tries to
send a value to <code>a</code> instead of receiving from it:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client_incorrect
  : Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt;
  = receive_channel(|a| {
      send_value_to(a, &quot;Hello World!&quot;.to_string(),
        wait(a, terminate()))
    });
<span class="boring">}
</span></code></pre></pre>
<p>If we try to compile the program, we would get an error message similar to the following:</p>
<pre><code>error[E0277]: the trait bound `Z: ContextLens&lt;(SendValue&lt;String, End&gt;, ()), ReceiveValue&lt;String, _&gt;, _&gt;` is not satisfied
   |
20 |     send_value_to(a, &quot;Hello World!&quot;.to_string(),
   |     ^^^^^^^^^^^^^ the trait `ContextLens&lt;(SendValue&lt;String, End&gt;, ()), ReceiveValue&lt;String, _&gt;, _&gt;` is not implemented for `Z`
   |
   |
49 |   N: ContextLens&lt;C, ReceiveValue&lt;T, B&gt;, B&gt;,
   |      ------------------------------------- send_value_to`
   |
   = help: the following implementations were found:
             &lt;Z as ContextLens&lt;(A1, C), A1, A2&gt;&gt;
</code></pre>
<p>The key meaning for the error message above is that the type <code>Z</code> does not implement
<code>ContextLens&lt;HList![SendValue&lt;String, End&gt;], ReceiveValue&lt;String, End&gt;, End&gt;</code>.
This is because although <code>Z</code> implements access to the first element of any
non-empty linear context, the first element in the linear context of <code>hello_client</code>
has the protocol <code>SendValue&lt;String, End&gt;</code>, but the call to <code>send_value_to(a, ...)</code>
requires the first element of the linear context to have the protocol
<code>ReceiveValue&lt;String, End&gt;</code>.</p>
<p>Error messages such as above may be difficult to understand for readers who are
new to Ferrite. But hopefully with some exercise, we should be able to get familiar
with the error message and understand the meaning behind them.</p>
<h1><a class="header" href="#hole-driven-development" id="hole-driven-development">Hole Driven Development</a></h1>
<h1><a class="header" href="#basic-constructs" id="basic-constructs">Basic Constructs</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#termination" id="termination">Termination</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#send--receive-values" id="send--receive-values">Send / Receive Values</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#send--receive-channels" id="send--receive-channels">Send / Receive Channels</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#external-choices" id="external-choices">External Choices</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#internal-choices" id="internal-choices">Internal Choices</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#advanced-constructs" id="advanced-constructs">Advanced Constructs</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#recursive-session-types" id="recursive-session-types">Recursive Session Types</a></h1>
<p>(TODO)</p>
<h1><a class="header" href="#communication" id="communication">Communication</a></h1>
<p>(TODO)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
