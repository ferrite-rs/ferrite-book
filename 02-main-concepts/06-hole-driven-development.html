<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Hole Driven Development - Writing Session-Typed Ferrite Programs in Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../ferrite.html"><strong aria-hidden="true">1.</strong> Writing Session-Typed Ferrite Programs in Rust</a></li><li class="chapter-item expanded "><a href="../01-getting-started/00-getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01-getting-started/01-installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../01-getting-started/02-hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../01-getting-started/03-communication.html"><strong aria-hidden="true">2.3.</strong> Client Communication</a></li><li class="chapter-item expanded "><a href="../01-getting-started/04-type-errors.html"><strong aria-hidden="true">2.4.</strong> Type Errors</a></li><li class="chapter-item expanded "><a href="../01-getting-started/05-session-types.html"><strong aria-hidden="true">2.5.</strong> Session Types</a></li></ol></li><li class="chapter-item expanded "><a href="../02-main-concepts/00-main-concepts.html"><strong aria-hidden="true">3.</strong> Main Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02-main-concepts/01-protocols.html"><strong aria-hidden="true">3.1.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/02-linear-context.html"><strong aria-hidden="true">3.2.</strong> Linear Context</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/03-sessions.html"><strong aria-hidden="true">3.3.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/04-channel-selectors.html"><strong aria-hidden="true">3.4.</strong> Channel Selectors</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/05-running-sessions.html"><strong aria-hidden="true">3.5.</strong> Running Sessions</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/06-hole-driven-development.html" class="active"><strong aria-hidden="true">3.6.</strong> Hole Driven Development</a></li></ol></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/00-ferrite-constructs.html"><strong aria-hidden="true">4.</strong> Ferrite Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-ferrite-constructs/01-termination.html"><strong aria-hidden="true">4.1.</strong> Termination</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/02-forward.html"><strong aria-hidden="true">4.2.</strong> Forward</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/03-include.html"><strong aria-hidden="true">4.3.</strong> Include</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/04-apply.html"><strong aria-hidden="true">4.4.</strong> Apply</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/05-step.html"><strong aria-hidden="true">4.5.</strong> Step</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/06-run-session.html"><strong aria-hidden="true">4.6.</strong> Run Session</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/07-receive-value.html"><strong aria-hidden="true">4.7.</strong> Receive Value</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/08-send-value.html"><strong aria-hidden="true">4.8.</strong> Send Value</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/09-receive-channel.html"><strong aria-hidden="true">4.9.</strong> Receive Channel</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/10-send-channel.html"><strong aria-hidden="true">4.10.</strong> Send Channel</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/11-external-choice.html"><strong aria-hidden="true">4.11.</strong> External Choice</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/12-internal-choice.html"><strong aria-hidden="true">4.12.</strong> Internal Choice</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/13-n-ary-choice.html"><strong aria-hidden="true">4.13.</strong> N-ary Choice</a></li><li class="chapter-item expanded "><a href="../03-ferrite-constructs/14-recursive.html"><strong aria-hidden="true">4.14.</strong> Recursive Session Types</a></li></ol></li><li class="chapter-item expanded "><a href="../04-shared-sesion-types/00-shared-session-types.html"><strong aria-hidden="true">5.</strong> Shared Session Types</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-shared-sesion-types/01-shared-provider.html"><strong aria-hidden="true">5.1.</strong> Shared Provider</a></li><li class="chapter-item expanded "><a href="../04-shared-sesion-types/02-run-shared-session.html"><strong aria-hidden="true">5.2.</strong> Run Shared Session</a></li><li class="chapter-item expanded "><a href="../04-shared-sesion-types/03-shared-client.html"><strong aria-hidden="true">5.3.</strong> Shared Client</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> TODO</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Session-Typed Ferrite Programs in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#hole-driven-development" id="hole-driven-development">Hole Driven Development</a></h1>
<p>Just like learning any new programming language, it may be overwhelming to
write your first session type program in Ferrite. To help you unstuck
when encountering compile errors, we encourage the use of <em>typed holes</em>
to discover what is needed to complete your program.</p>
<p>The use of typed holes are common in languages like Haskell, Agda, and Idris.
In Rust, there isn't officially support for using typed holes, but we can
somewhat emulate the feature using techniques described in this chapter.</p>
<h2><a class="header" href="#todo-placeholder" id="todo-placeholder">Todo Placeholder</a></h2>
<p>Suppose we are a total beginner again, and we want to write our first
<a href="../01-getting-started/02-hello-world.html">hello world provider</a>.
We start by defining the session type we want, which is
<code>SendValue&lt;String, End&gt;</code>, and we can then write down the outline
for our Ferrite program as follows:</p>
<pre><code class="language-rust noplaypen">let hello_provider: Session&lt;SendValue&lt;String, End&gt;&gt; = todo!();
</code></pre>
<p>The <a href="https://doc.rust-lang.org/std/macro.todo.html"><code>todo!</code></a> macro allows
us to put a placeholder in unfinished Rust code so that we can try and
compile the code and see if there is any type error. By writing our code
step by step and filling the blank with <code>todo!()</code>, we can narrow down
the potential places where our code is incorrect.</p>
<p>At this stage, we should be able to compile our program with no error.
This shows that the protocol that we have defined, <code>SendValue&lt;String, End&gt;</code>,
is a valid session type. If we have gotten a compile error otherwise,
it could have been caused by us trying to write an invalid protocol
like <code>SendValue&lt;String, String&gt;</code>.</p>
<p>When using <code>todo!()</code>, the Rust compiler might emit warnings about
unreacheable code. Since we are still writing our program, we can
add the <code>#![allow(unreachable_code)]</code> pragma to disable the warning
temporarily until we finish writing the code.</p>
<h2><a class="header" href="#unit-placeholder" id="unit-placeholder">Unit Placeholder</a></h2>
<p>Now that we have defined the outline, we can move to the next step
and try to write the first step. By looking at the first part
<code>SendValue&lt;String, ...&gt;</code>, we know that we have to send a string
value. But we might not know what should be done after sending
the value, so we could write something like follows:</p>
<pre><code class="language-rust noplaypen">let hello_provider: Session&lt;SendValue&lt;String, End&gt;&gt; =
  send_value(&quot;Hello World!&quot;.to_string(), todo!());
</code></pre>
<p>We can try to compile our code again, and Rust will accept the code
we have written. However the use of <code>todo!()</code> does not tell us
how we should continue our program. In languages like Haskell,
we could have used <code>_</code> instead of <code>todo!()</code>, and GHC would tell
us what should be the type of the expression in the hole. In Rust,
we would instead use the unit type <code>()</code> to deliberately cause
a compile error:</p>
<pre><code class="language-rust noplaypen">let hello_provider: Session&lt;SendValue&lt;String, End&gt;&gt; =
  send_value(&quot;Hello World!&quot;.to_string(), ());
</code></pre>
<p>Now if we compile our code, we would get a compile error from Rust
that looks like follows:</p>
<pre><code>error[E0308]: mismatched types
 |
 |       send_value(&quot;Hello World!&quot;.to_string(), ());
 |                                              ^^ expected struct `PartialSession`, found `()`
 |
 = note: expected struct `PartialSession&lt;(), End&gt;`
         found unit type `()`

</code></pre>
<p>With this compile error, we can know that we are supposed to fill in the hole
with Rust expression that has the type <code>PartialSession&lt;(), End&gt;</code>, or <code>Session&lt;End&gt;</code>.</p>
<p>Sometimes we may also intuitively think of a type that should be in a hole.
In such case, we can also use the <code>todo!() as T</code> pattern to verify if our intuition
is correct. So we can for example write:</p>
<pre><code class="language-rust noplaypen">let hello_provider: Session&lt;SendValue&lt;String, End&gt;&gt; =
  send_value(&quot;Hello World!&quot;.to_string(), todo!() as Session&lt;End&gt;);
</code></pre>
<p>And our code will compile successfully. If we were to annotate it with an
invalid type, such as <code>todo()! as Session&lt;ReceiveValue&lt;String, End&gt;&gt;</code> again,
Rust will also return a compile error.</p>
<p>Now that we know the continuation needs to have the type <code>Session&lt;End&gt;</code>, we
can then fill in the blank with <code>terminate()</code> and complete our program.</p>
<h2><a class="header" href="#underscores" id="underscores">Underscores</a></h2>
<p>Now that we have finished <code>hello_provider</code>, we can try implementing
<a href="../01-getting-started/03-communication.html"><code>hello_client</code></a> once again.
Supposed we know that the first expression to match <code>ReceiveChannel&lt;...&gt;</code>
is <code>receive_channel</code>, but we don't know what would be in the linear context,
we can write our program as follows:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    todo!() as PartialSession&lt;HList![_], End&gt;
  });
</code></pre>
<p>The code above will still compile successfully with Rust, so we know that
in our continuation, we have one element in the linear context as
denoted by <code>HList![_]</code>, but we don't yet know what it is.
Rust allows us to use <code>_</code> as a wildcard in places where it can infer the
type, such as the case when we use it in <code>todo!() as ...</code>. Using this
technique, we can also slowly narrow down our type definition and not
get overwhelmed by an overly long error message.</p>
<p>Now we can try and fill in the <code>_</code> with a bogus protocol like <code>End</code>
and see what happens:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    todo!() as PartialSession&lt;HList![End], End&gt;
  });
</code></pre>
<p>Now if we try to compile our program again, we would get a compile error
that looks like follows:</p>
<pre><code>error[E0271]: type mismatch resolving `&lt;() as AppendContext&lt;(SendValue&lt;String, End&gt;, ())&gt;&gt;::Appended == (End, ())`
 |
 |       receive_channel(move |a| {
 |       ^^^^^^^^^^^^^^^ expected struct `SendValue`, found struct `End`
 |
 = note: expected type `(SendValue&lt;String, End&gt;, ())`
           found tuple `(End, ())`
</code></pre>
<p>The key information is in the last two lines, which states that there is a type mismatch
between the expected type <code>(SendValue&lt;String, End&gt;, ())</code> and the actual type <code>(End, ())</code>.
Recall from <a href="./02-linear-context.html">previous chapter</a> that this is the desugared versions
of the expected list <code>HList![SendValue&lt;String, End&gt;]</code> and the actual list <code>HList![End]</code>.
Using this information, we are able to fill in the correct type for our hole:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    todo!() as PartialSession&lt;HList![SendValue&lt;String, End&gt;], End&gt;
  });
</code></pre>
<p>When writing complex session type programs, we can also use <code>_</code> in places
where we do not care about the actual type. For example, we may be interested
to know whether the there is one channel in the linear context in the form
<code>SendValue&lt;String, ...&gt;</code>. In that can we can also write our code as follows:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    todo!() as PartialSession&lt;HList![SendValue&lt;String, _&gt;], _&gt;
  });
</code></pre>
<p>Now that we know the first session type in the linear context is
in the form <code>SendValue&lt;String, ...&gt;</code>, we can attempt to write the next
part of our program. However suppose that we forgot that the behavior
of protocols is inverted on the client side, we may try to write
a program that sends a value to channel <code>a</code> instead of receiving from it:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    send_value_to(a, &quot;Hello World!&quot;.to_string(), todo!())
  });
</code></pre>
<p>If we try to compile the code, we would get an error such as follows,
which is the same error as <a href="./04-channel-selectors.html">previously described</a>:</p>
<pre><code>error[E0277]: the trait bound `Z: ContextLens&lt;(SendValue&lt;String, End&gt;, ()), ReceiveValue&lt;String, _&gt;, _&gt;` is not satisfied
 |
 |         send_value_to(a, &quot;Hello World!&quot;.to_string(), todo!())
 |         ^^^^^^^^^^^^^ the trait `ContextLens&lt;(SendValue&lt;String, End&gt;, ()), ReceiveValue&lt;String, _&gt;, _&gt;` is not implemented for `Z`
 |
</code></pre>
<p>With the help of <code>todo!()</code>, we are able to spot the type errors in our program before finish
writing the whole program. It saves us the effort of figuring out what to fill in
the blank inside <code>send_value_to(a, &quot;Hello World!&quot;.to_string(), ...)</code>, as our program
is incorrect anyway.</p>
<h2><a class="header" href="#comment" id="comment">Comment</a></h2>
<p>Sometimes we may have written too much code, and by the time we try to compile our
program, we get a big list of compile errors that are difficult to decipher.
In such case, it may be helpful to comment out part of our Ferrite program
and replace them with <code>todo!()</code>, to find out the initial place where the
error occured.</p>
<p>For example, suppose we finished writing the wrong implementation of <code>hello_client</code>,
we can debug our code by commenting out the code to become something like:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    todo!()
    // send_value_to(a, &quot;Hello World!&quot;.to_string(),
    //   wait(a, terminate()))
  });
</code></pre>
<p>If we build our program at this step, the compilation will be successful again.
We can then move forward to the next step of our program while still
commenting out the remaining part:</p>
<pre><code class="language-rust noplaypen">let hello_client: Session&lt;ReceiveChannel&lt;SendValue&lt;String, End&gt;, End&gt;&gt; =
  receive_channel(move |a| {
    send_value_to(a, &quot;Hello World!&quot;.to_string(),
      todo!())
    //   wait(a, terminate()))
  });
</code></pre>
<p>At this step, we would then get a compile error. We can then know that
the cause of the error is from our use of <code>send_value_to</code>, and is
unaffected by the remaining expression <code>wait(a, terminate())</code>
because they have been commented out and replaced with <code>todo!()</code>.</p>
<h2><a class="header" href="#rust-ide" id="rust-ide">Rust IDE</a></h2>
<p>When developing Ferrite programs, it may be helpful to use Rust IDEs
such as <a href="https://rust-analyzer.github.io/">Rust Analayzer</a>. The IDE
would show the hints on the types of the variables and functions.
Using and IDE, we can for example easily see that the type of
channel variables, such as <code>a</code> in <code>hello_client</code> has the type <code>Z</code>.
This can be useful especially for beginners, who may be unfamiliar
with the various types defined in Ferrite.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../02-main-concepts/05-running-sessions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../03-ferrite-constructs/00-ferrite-constructs.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../02-main-concepts/05-running-sessions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../03-ferrite-constructs/00-ferrite-constructs.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
