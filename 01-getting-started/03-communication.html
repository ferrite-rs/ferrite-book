<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Client Communication - Writing Session-Typed Ferrite Programs in Rust</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../ferrite.html"><strong aria-hidden="true">1.</strong> Writing Session-Typed Ferrite Programs in Rust</a></li><li class="chapter-item expanded "><a href="../01-getting-started/00-getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../01-getting-started/01-installation.html"><strong aria-hidden="true">2.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="../01-getting-started/02-hello-world.html"><strong aria-hidden="true">2.2.</strong> Hello World</a></li><li class="chapter-item expanded "><a href="../01-getting-started/03-communication.html" class="active"><strong aria-hidden="true">2.3.</strong> Client Communication</a></li><li class="chapter-item expanded "><a href="../01-getting-started/04-type-errors.html"><strong aria-hidden="true">2.4.</strong> Type Errors</a></li><li class="chapter-item expanded "><a href="../01-getting-started/05-session-types.html"><strong aria-hidden="true">2.5.</strong> Session Types</a></li></ol></li><li class="chapter-item expanded "><a href="../02-main-concepts/00-main-concepts.html"><strong aria-hidden="true">3.</strong> Main Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../02-main-concepts/01-protocols.html"><strong aria-hidden="true">3.1.</strong> Protocols</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/02-linear-context.html"><strong aria-hidden="true">3.2.</strong> Linear Context</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/03-sessions.html"><strong aria-hidden="true">3.3.</strong> Sessions</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/04-channel-selectors.html"><strong aria-hidden="true">3.4.</strong> Channel Selectors</a></li><li class="chapter-item expanded "><a href="../02-main-concepts/05-hole-driven-development.html"><strong aria-hidden="true">3.5.</strong> Hole Driven Development</a></li></ol></li><li class="chapter-item expanded "><a href="../03-basic-constructs/00-basic-constructs.html"><strong aria-hidden="true">4.</strong> Basic Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../03-basic-constructs/01-termination.html"><strong aria-hidden="true">4.1.</strong> Termination</a></li><li class="chapter-item expanded "><a href="../03-basic-constructs/02-send-receive-values.html"><strong aria-hidden="true">4.2.</strong> Send / Receive Values</a></li><li class="chapter-item expanded "><a href="../03-basic-constructs/03-send-receive-channels.html"><strong aria-hidden="true">4.3.</strong> Send / Receive Channels</a></li><li class="chapter-item expanded "><a href="../03-basic-constructs/04-external-choice.html"><strong aria-hidden="true">4.4.</strong> External Choice</a></li><li class="chapter-item expanded "><a href="../03-basic-constructs/05-internal-choice.html"><strong aria-hidden="true">4.5.</strong> Internal Choice</a></li></ol></li><li class="chapter-item expanded "><a href="../04-advanced-constructs/00-advanced-constructs.html"><strong aria-hidden="true">5.</strong> Advanced Constructs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../04-advanced-constructs/01-recursive-session-types.html"><strong aria-hidden="true">5.1.</strong> Recursive Session Types</a></li><li class="chapter-item expanded "><a href="../04-advanced-constructs/02-communication.html"><strong aria-hidden="true">5.2.</strong> Communication</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Shared Session Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Example Usage</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Communication Protocols</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Shared Resources</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Ferrite Internals</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Higher Kinded Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> Cloaking Constraints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> Optics</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> Row Polymorphism</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Conclusion</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> TODO</div></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Writing Session-Typed Ferrite Programs in Rust</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#client-communication" id="client-communication">Client Communication</a></h1>
<p>In the previous chapter, we defined a hello provider and then run it
immediately using <code>run_session_with_result</code>. However in practical applications,
our Ferrite programs will typically have more complex session types, and
we would want to run multiple programs in parallel that communicate with
each others.</p>
<p>To demonstrate that, instead of running <code>hello_provider</code> directly, we can
define a <code>hello_client</code> that <em>communicates</em> with a provider of the <code>Hello</code>
protocol, and then link it with <code>hello_provider</code>.</p>
<p>First, we define <code>hello_client</code> to have the following type:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; = ...
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>hello_client</code> has the Rust type <code>Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt;</code>,
indicating that it is a Ferrite program offering the session type
<code>ReceiveChannel&lt;Hello, End&gt;</code>. Here we encounter a new session type in the form
<code>ReceiveChannel&lt;A, B&gt;</code>, which is used to <em>receive a channel</em> of session type
<code>A</code> offered by some provider, and then continue offering session type <code>B</code>.</p>
<h2><a class="header" href="#channels" id="channels">Channels</a></h2>
<p>Ferrite allows sending and receiving of <em>channels</em>, which represent the client
end point to communicate with a provider that offers the channel's session type.
At high level, we can think of receiving a channel using <code>ReceiveChannel&lt;A, B&gt;</code>
is similar to plain Rust functions with function traits like <code>FnOnce(A) -&gt; B</code>.
In other words, <code>ReceiveChannel</code> is the equivalent of function types in Ferrite.</p>
<p>There is however one important distinction of <code>ReceiveChannel</code> from regular
Rust functions. That is channels received from <code>ReceiveChannel</code> must be
used <em>linearly</em>, i.e. they cannot be ignored or dropped.
We will revisit this property in later chapters to see why linearity is
important, and why bare Rust code is not sufficient to support linearity.</p>
<p>Now back to our <code>hello_client</code> example. The session type
<code>ReceiveChannel&lt;Hello, End&gt;</code> indicates that <code>hello_client</code> is <em>receiving</em>
a channel of session type <code>Hello</code>, and then terminates with <code>End</code>.
To implement such a session type, we can implement <code>hello_client</code> as follows:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
    receive_channel(|a| {
      receive_value_from(a, move |greeting| {
        println!(&quot;Received greetings from provider: {}&quot;, greeting);
        wait(a, terminate())
      })
    });
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>hello_client</code> body looks slightly more complicated than <code>hello_provider</code>.
To understand what's going on, we will go through each line of
<code>hello_client</code>'s body. Starting with <code>receive_channel</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>receive_channel(|provider| { ... })
<span class="boring">}
</span></code></pre></pre>
<p>To match the final session type <code>ReceiveChannel&lt;Hello, End&gt;</code> that is
offered by <code>hello_client</code>, we use <code>receive_channel</code> to receive a
channel of session type <code>Hello</code>, and then binds it to the <em>channel variable</em>
<code>a</code>. This is similar to a Rust function accepting an argument
and bind it to a variable.</p>
<p>Inside the continuation <code>...</code>, since we have received the <code>Hello</code> channel
already, we will continue to offer the session type <code>End</code>.  To do that,
we just need to eventually terminate <code>hello_client</code>. However we cannot
terminate <code>hello_client</code> just yet, because the channel variable <code>a</code>
is <em>linear</em>, and we must fully consume it before we can terminate.</p>
<p>Recall that <code>Hello</code> is a type alias, so the actual session type of
the channel variable <code>a</code> is <code>SendValue&lt;String, End&gt;</code>.
But instead of having to offer that, we are acting as the <em>client</em>
to consume the session type <code>SendValue&lt;String, End&gt;</code>. Since the provider
is expected to send a <code>String</code> value, as a client we are expected to
<em>receive</em> a <code>String</code> value from the provider. We can do that using
<code>receive_value_from</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>receive_value_from(provider, move |greeting| {
  println!(&quot;Received greetings from provider: {}&quot;, greeting);
  ...
})
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>receive_value_from</code> to receive a value sent from the <code>a</code>
channel, and then bind the received <code>String</code> value to the Rust variable
<code>greeting</code>. We then print out the value of <code>greeting</code> using <code>println!</code>.
Following that, in the continuation <code>...</code>, the session type
of <code>a</code> <em>changes</em> from <code>SendValue&lt;String, End&gt;</code> to
become <code>End</code>.</p>
<p>Unlike regular Rust variables, each time we interacts with a channel
variable, the session type of the channel variable is <em>updated</em>
to its continuation session type. Since Ferrite channels are linear,
we have to continuously interact with the channel until it is
fully terminated.</p>
<p>After calling <code>receive_value_from</code>, we have the channel variable
<code>a</code> with session type <code>End</code>, and we need to offer the session
type <code>End</code> by terminating. But we can't terminate just yet, because
<code>End</code> simply indicates that the provider will eventually terminates,
but may not yet been terminated. Hence we would first have to wait
for <code>a</code> to terminate using <code>wait</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>wait(provider, terminate())
<span class="boring">}
</span></code></pre></pre>
<p>We use <code>wait</code> to wait for the provider on the other side of a
channel to terminate. After that, the <code>a</code> channel is discarded,
and we don't have anymore unused channel variable. With that, we
can finally terminate our program using <code>terminate()</code>.</p>
<h2><a class="header" href="#linking-provider-with-client" id="linking-provider-with-client">Linking Provider With Client</a></h2>
<p>We have now defined a <code>hello_client</code> program that can accept channel
from any provider offering the session type <code>Hello</code>.
In theory, we can call <code>hello_client</code> with any provider that offers
<code>Hello</code>, not just <code>hello_provider</code>.</p>
<p>To link <code>hello_client</code> specifically with <code>hello_provider</code>, we have to
explicitly ask Ferrite to perform the linking. This can be done
using <code>apply_channel</code>:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  let main: Session&lt;End&gt; = apply_channel(hello_client, hello_provider);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>apply_channel</code> construct is provided by Ferrite to link a
client Ferrite program of session type <code>ReceiveChannel&lt;A, B&gt;</code>
with a provider Ferrite program of session type <code>A</code>,
resulting in a new Ferrite program of session type <code>B</code>
as the result.</p>
<p>We can think of the form <code>apply_channel(f, x)</code> as being similar similar to
regular function application in the form <code>f(x)</code>. With <code>f</code> having the Rust type
<code>FnOnce(A) -&gt; B</code> and <code>x</code> having the Rust type <code>A</code>, the result type of applying
<code>x</code> to <code>func</code> would be <code>B</code>.</p>
<h2><a class="header" href="#run-session" id="run-session">Run Session</a></h2>
<p>After applying <code>hello_provider</code> to <code>hello_client</code>, we now have a single <code>main</code>
program. When <code>main</code> is executed, it will run both <code>hello_provider</code> and
<code>hello_client</code> in parallel, and establish a communication channel between
the two processes.</p>
<p>Since <code>main</code> has the session type <code>End</code>, we can use the Ferrite construct
<code>run_session</code> to run the program:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>  run_session(main).await;
<span class="boring">}
</span></code></pre></pre>
<p><code>run_session</code> accepts any Ferrite program offering the session type <code>End</code>,
executes the program, and wait for it to terminate. <code>run_session</code> is
similar to <code>run_session_with_result</code>, other than it does not expect
the Ferrite program to send back any Rust value as the result.</p>
<h2><a class="header" href="#full-program" id="full-program">Full Program</a></h2>
<p>Putting everything together, we now have our second hello world program
that is made of a <code>hello_provider</code> and a <code>hello_client</code> communicating
with each others.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use ferrite_session::prelude::*;

type Hello = SendValue&lt;String, End&gt;;

#[tokio::main]
async fn main()
{
  let hello_provider: Session&lt;Hello&gt; =
    send_value(&quot;Hello World!&quot;.to_string(), terminate());

  let hello_client: Session&lt;ReceiveChannel&lt;Hello, End&gt;&gt; =
    receive_channel(|a| {
      receive_value_from(a, move |greeting| {
        println!(&quot;Received greetings from provider: {}&quot;, greeting);
        wait(a, terminate())
      })
    });

  let hello_client_partial: PartialSession&lt;
    HList![SendValue&lt;String, End&gt;],
    End,
  &gt; = receive_value_from(Z, move |greeting| {
    println!(&quot;Received greetings from provider: {}&quot;, greeting);
    wait(Z, terminate())
  });

  let main: Session&lt;End&gt; = apply_channel(hello_client, hello_provider);

  run_session(main).await;
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../01-getting-started/02-hello-world.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../01-getting-started/04-type-errors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../01-getting-started/02-hello-world.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../01-getting-started/04-type-errors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
